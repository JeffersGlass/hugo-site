---
title: "Advent of Code 2021"
date: 2021-11-30T02:30:42-05:00
draft: false
tags:
- codeadvent
- codeadvent2021
- python
slug_image: 1200px-Python-logo-notext.png
---
<p class="post-p">Is it Advent of Code time again? Well, here goes nothing. Let's see wha we can cook up.</p>
<p class="post-p">I'm planning on completing most (all) of this year's challenges in Python, <a href="/post/advent-of-code-2020/">same as last year</a>.</p>
<div class="w-auto pt-2 pb-4 pl-2 mr-2 -ml-2 align-top bg-gray-200 md:w-98">
    <p class="text-2xl">Table of Contents</p>
    <div class="ml-8 font-semibold">
        <p><a href="#day1">Day 1 - Sonar Sweep</a></p>
        <p><a href="#day2">Day 2 - Dive!</a></p>
        <p><a href="#day4">Day 4 - Giant Squid</a></p>
    </div>
</div>
<h2 class="table-cell w-auto pb-1 border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day1">Day 1 - Sonar Sweep</h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">I feel like it's Advent of Code tradition for me to read in the input from file (as strings) and try to do comparisons on it like ints, forgetting to cast them to intergers. Which means I was comparing textually, instead of numerically, so my answer was off by <span class="italic">two</span>. Absurd. </p>
<p class="post-p">You really could do <a href="https://adventofcode.com/2021/day/1">today's challenge</a> entirely in one line, but I think it's slightly more readable broken up as I've done. Here's the complete code:</p>
<p class="code-title">Day1/Part1.py</p>
{{< highlight python3 "hl_lines=2">}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

numDecreases = len([pair for pair in zip(data[:-1], data[1:]) if pair[0] < pair[1]])

print(f"{numDecreases=}")
{{< /highlight >}}
<p class="post-img-caption">The offending line, where I remembered to cast the input to ints.</p>
<h4 class="pt-4 pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Part 2 could also probably be inlined, but the list-comprehension-within-list-comprehension is, again, not the most readable thing, I think. Breaking out the three key steps (creating triples of the data, finding their sums, and finding where adjacent sums are decreasing) into 3 lines of code I think makes the solution more parsable.</p>
<p class="code-title">Day1/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

triples = zip(data[:-2], data[1:-1], data[2:])
windowSums = [sum(list(t)) for t in triples]

numDecreases = len([t for t in zip(windowSums[:-1], windowSums[1:]) if t[0] < t[1]])

print(f"{numDecreases=}")

{{< /highlight >}}
<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day2">Day 2 - Dive!</h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">The first part of today's challenge has us dealing with a list of things that happen sequentially (tracking the horizontal and vertical movements of our submarine), but the answer only has to do with summing them in some specific ways. This smells strongly of a 'gotcha' coming in part 2 - if we can the easy, just-sum-it-up route for part 1, we won't be able to reuse any code for part 2 when the order actually matters. But that's alright, I guess, we'll take the easy route on this one.</p>
<p class="post-p">There's a fair amount of repetition in my list comprehensions here, but for a 7-line program I don't terribly feel like factoring it out.</p>
<p class="code-title">Day2/Part1.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal = sum([step[1] for step in data if step[0] == 'forward'])
depth = sum([step[1] for step in data if step[0] == 'down']) - sum([step[1] for step in data if step[0] == 'up'])
print(f"Solution product is {horizontal * depth =}")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">As expected, we're paying the (small) price for not doing the first part iteratively. That's alright, we can implement it now.</p>
<p class="post-p">This does give me a chance to play with a new feature of Python 3.10: structural pattern matching. It's like a switch-case structure on steroids. To make sure I'm running this code in Python 3.10 specifically, I'll use pipenv to lock the version to 3.10.0 by running <code class="code">pipenv install --python 3.10</code> on the command line.</p>
<p class="post-p">Our code is ultimately fairly simple; thankfully, I encountered no "unmatched instruction" errors, which means I parsed the input correctly.</p>
<p class="code-title">Day2/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal, depth, aim = 0,0,0

for d in data:
    match d:
        case ('down', num):
            aim += num
        case ('up', num):
            aim -= num
        case ('forward', num):
            horizontal += num
            depth += aim * num
        case _:
            raise ValueError(f"Unmatched instruction {d}")

print(f"Solution is {horizontal*depth= }")
{{< /highlight >}}

<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day4">Day 4 - Giant Squid</h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Today my biggest obstacle was, as is often the case, myself trying to be too clever and concise. <a href="https://adventofcode.com/2021/day/4">Today's challenge</a> invovled parsing a somewhat more involved text file of inputs, and then further processing that input to make it into a useful data structure. Rather than load each bingo card as a 2D array, I used the input data to create two separate arrays, one indexed by rows, the other by columns, with boards at the same position representing the same board. Determining whether a board is winning (given a list of called numbers) is a simple as asking whether any of the lines (rows or columns) in that board have all their members in the called numbers.</p>
<p class="post-p">Had I simply constructed each type of input using <code class="code">for</code> loops, this would have been fairly simply, but I wanted everything packaged up nice in a list comprehension... which took me a spell to troubleshoot and get right. Ah well.</p>
<p class="code-title">Day4/part1.py</p>
<div class="overflow-y-scroll h-124">
    {{< highlight python3 >}}
    with open ("input.txt", 'r') as infile:
        inputChunks = infile.read().split('\n\n')
    
    #---Parse the Input to make it useful----
    
    allCalledNumbers = [int(num) for num in inputChunks[0].split(',')]
    boards = [' '.join(chunk.split('\n')) for chunk in inputChunks[1:]] #get boards
    
    #Make board list of ints instead of long string by splitting every 3 characters
    intBoards = [[int(b[n:n+2]) for n in range(0, len(b), 3)] for b in boards]
    
    #boardrows is a list of boards, each of which are a list of rows in each board,
    #each of which is a list of ints
    boardRows = [[b[index:index+5] for index in range(0, 25, 5)] for b in intBoards]
    
    #boardcols is a list of boards, each of of which is a list of columns in each board,
    #each of which is a list of ints
    boardCols = [[[b[row][index] for row in range(5)] for index in range(5)] for b in boardRows]
    
    #---Define some functions to help us solve the problem as written---
    
    #For a given board (by row or column), are any of its lines made up only of numbers in 'calledNums'?
    def isBoardAWin(board, calledNums):
        return any([all([num in calledNums for num in line]) for line in board])
    
    #Score is (sum of uncalled numbers on board) * (last number called)
    def calcScore(board, calledNumbers):
        unusedNumbers = [num for line in board for num in line if num not in calledNumbers]
        return sum(unusedNumbers) * calledNumbers[-1]
    
    def doWin(board, calledNumbers):
        print(f"Score is {calcScore(b, calledSoFar)}")
        exit()
    
    #---Find solution---
    
    for i in range(len(allCalledNumbers)):
        calledSoFar = allCalledNumbers[:i]
        print(f"Searching for wins with numbers {calledSoFar}")
        winner = False
        for b in boardRows:
            if isBoardAWin(b, calledSoFar):
                print(f"Winner board by row! \n {b}")
                doWin(b, calledSoFar)
    
    
        for b in boardCols:
            if isBoardAWin(b, calledSoFar):
                print(f"Winner board by column! \n {b}")
                doWin(b, calledSoFar)
    
        print(f"No winners after {i} numbers, calling next number")
    {{< /highlight >}}
</div>
<p class="post-img-caption">Scroll to see complete code</p>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Thankfully, the infrastructure I built for part 1 of this puzzle was very useful for part to. Basically, instead of iterating through increasingly long lists of called numbers until the <span class="italic">first</span> winning is found, keep going until only 1 board has not won, recall that it's the winner, then keep adding called numbers until it does win.</p>
<p class="post-p">Since all of the setup and parsing steps are the same, I'll only include the solution finding part of the code, for brevity:</p>
<p class="code-title">Day2/Part2.py <span class="italic">(Partial)</span></p>
{{< highlight python3 "linenostart=35">}}
#---Find solution---

hasWon = [False for b in boards]

for i in range(len(allCalledNumbers)):
    calledSoFar = allCalledNumbers[:i]
    for x, b in enumerate(boardRows):
        if isBoardAWin(b, calledSoFar):
            hasWon[x] = True
            
    for x, b in enumerate(boardCols):
        if isBoardAWin(b, calledSoFar):
            hasWon[x] = True

    print(f"After calling {i} numbers,", end = " ")
    if hasWon.count(False) == 1:
        winningIndex = hasWon.index(False)
        print(f"found last board to win at index: {winningIndex}")
    elif hasWon.count(False) == 0:
        print(f"This board wins after {i} numbers called,",)
        doWin(boardCols[winningIndex], calledSoFar)
    else:
        print(f"{hasWon.count(False)} boards have not won")
{{< /highlight >}}

