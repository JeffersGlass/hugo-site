---
title: "Advent of Code 2021"
date: 2021-11-30T02:30:42-05:00
draft: false
tags:
- codeadvent
- codeadvent2021
- python
slug_image: 1200px-Python-logo-notext.png
description: "Solutions to the annual holiday coding challenge, all in Python and commented for your viewing pleasure."
images: ['https://new.jeff.glass/post/advent-of-code-2021/python_cover.png']
---
<p class="post-p">Is it Advent of Code time again? Well, here goes nothing. Let's see wha we can cook up.</p>
<p class="post-p">I'm planning on completing most (all) of this year's challenges in Python, <a href="/post/advent-of-code-2020/">same as last year</a>.</p>
<div class="w-auto pt-2 pb-4 pl-2 mr-2 -ml-2 align-top bg-gray-200 md:w-130">
    <p class="text-2xl">Table of Contents</p>
    <div class="ml-8 font-semibold">
        <p><a href="#day1">Day 1 - Sonar Sweep</a></p>
        <p><a href="#day2">Day 2 - Dive!</a></p>
        <p><a href="#day3">Day 3 - Binary Diagnostic</a></p>
        <p><a href="#day4">Day 4 - Giant Squid</a></p>
        <p><a href="#day5">Day 5 - Hydrothermal Venture</a></p>
        <p><a href="#day6">Day 6 - Lanternfish</a></p>
        <p><a href="#day7">Day 7 - The Treachery of Whales</a></p>
    </div>
</div>
<div class="relative-anchor" id="day1">
    <h2 class="table-cell w-auto pb-1 border-b-4 border-gray-200 md:w-128 post-h2">Day 1 - Sonar Sweep</h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">I feel like it's Advent of Code tradition for me to read in the input from file (as strings) and try to do comparisons on it like ints, forgetting to cast them to intergers. Which means I was comparing textually, instead of numerically, so my answer was off by <span class="italic">two</span>. Absurd. </p>
<p class="post-p">You really could do <a href="https://adventofcode.com/2021/day/1">today's challenge</a> entirely in one line, but I think it's slightly more readable broken up as I've done. Here's the complete code:</p>
<p class="code-title">Day1/Part1.py</p>
{{< highlight python3 "hl_lines=2">}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

numDecreases = len([pair for pair in zip(data[:-1], data[1:]) if pair[0] < pair[1]])

print(f"{numDecreases=}")
{{< /highlight >}}
<p class="post-img-caption">The offending line, where I remembered to cast the input to ints.</p>
<h4 class="pt-4 pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Part 2 could also probably be inlined, but the list-comprehension-within-list-comprehension is, again, not the most readable thing, I think. Breaking out the three key steps (creating triples of the data, finding their sums, and finding where adjacent sums are decreasing) into 3 lines of code I think makes the solution more parsable.</p>
<p class="code-title">Day1/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

triples = zip(data[:-2], data[1:-1], data[2:])
windowSums = [sum(list(t)) for t in triples]

numDecreases = len([t for t in zip(windowSums[:-1], windowSums[1:]) if t[0] < t[1]])

print(f"{numDecreases=}")

{{< /highlight >}}
<div class="relative-anchor" id="day2">
    <h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2">Day 2 - Dive!</h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">The first part of today's challenge has us dealing with a list of things that happen sequentially (tracking the horizontal and vertical movements of our submarine), but the answer only has to do with summing them in some specific ways. This smells strongly of a 'gotcha' coming in part 2 - if we can the easy, just-sum-it-up route for part 1, we won't be able to reuse any code for part 2 when the order actually matters. But that's alright, I guess, we'll take the easy route on this one.</p>
<p class="post-p">There's a fair amount of repetition in my list comprehensions here, but for a 7-line program I don't terribly feel like factoring it out.</p>
<p class="code-title">Day2/Part1.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal = sum([step[1] for step in data if step[0] == 'forward'])
depth = sum([step[1] for step in data if step[0] == 'down']) - sum([step[1] for step in data if step[0] == 'up'])
print(f"Solution product is {horizontal * depth =}")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">As expected, we're paying the (small) price for not doing the first part iteratively. That's alright, we can implement it now.</p>
<p class="post-p">This does give me a chance to play with a new feature of Python 3.10: structural pattern matching. It's like a switch-case structure on steroids. To make sure I'm running this code in Python 3.10 specifically, I'll use pipenv to lock the version to 3.10.0 by running <code class="code">pipenv install --python 3.10</code> on the command line.</p>
<p class="post-p">Our code is ultimately fairly simple; thankfully, I encountered no "unmatched instruction" errors, which means I parsed the input correctly.</p>
<p class="code-title">Day2/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal, depth, aim = 0,0,0

for d in data:
    match d:
        case ('down', num):
            aim += num
        case ('up', num):
            aim -= num
        case ('forward', num):
            horizontal += num
            depth += aim * num
        case _:
            raise ValueError(f"Unmatched instruction {d}")

print(f"Solution is {horizontal*depth= }")
{{< /highlight >}}
<div class="relative-anchor" id="day3">
    <h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2">Day 3 - Binary Diagnostic </h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Ah, day 3 of Advent of Code, where we traditionally get into nested-processing, working with binary, and parsing numbers based on their digits. I don't know that this literally happens on day 3 every year, but it seems a familiar progression in the early days of an Advent of Code challenge. My first thought is - let's make sure we iterate through the entire input as few times as possible, something made easier by the fact that epsilon and gamma are, in some sense, complements of each other.</p>
<p class="post-p">This one's not too hard - using a <code class="code">defaultdict</code> from the <code class="code">collections</code> module makes the process of adding up the number of "1"'s in all the input numbers a little cleaner.</p>
<p class="code-title">Day3/Part1.py</p>
{{< highlight python3 >}}
from collections import defaultdict

with open("input.txt", 'r') as infile:
    data = infile.read().split('\n')

numInputs = len(data)
onesCount = defaultdict(lambda: 0)

#Count the number of "1"'s at each digit position in all of the input numbers
for num in data:
    for i, digit in enumerate(num):
        onesCount[i] += int(digit)

#Calculate gamma, epison as lists of strings ("1" and "0")
gamma = [("1" if onesCount[i] > (numInputs / 2) else "0") for i in range(len(onesCount))]
epsilon = [("1" if gamma[i] == "0" else "0") for i in range(len(onesCount))]

#Concatenate lists, as 0b to represent binary, cast to int
result = int('0b' + ''.join(gamma), 2) * int('0b' + ''.join(epsilon), 2)
print(f"{gamma= } {epsilon= } {result= }")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Now we're moving into the realm of processing some input data with multiple passes, while restricting which data is in each pass based on our processing of previous steps. My initial solution was a little cumbersome, but I think gets the intention accross pretty well. </p>
<p class="code-title">Day2/Part2.py (Version 1)</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    inputdata = infile.read().split('\n')

def mostCommonDigitInPosition(data, position):
    return "1" if sum([int(num[position]) for num in data]) >= len(data)/2 else "0"


oxyData = [d for d in inputdata]
co2Data = [d for d in inputdata]

#find Oxygen Rating
for i in range(len(inputdata[0])):
    if len(oxyData) <= 1: break
    MCD_o2 = mostCommonDigitInPosition(oxyData, i)
    oxyData = [t for t in oxyData if t[i] == MCD_o2]

#find CO2 Rating
for i in range(len(inputdata[0])):
    if len(co2Data) <= 1: break
    MCD_co2 = mostCommonDigitInPosition(co2Data, i)
    co2Data = [t for t in co2Data if t[i] != MCD_co2]

if len(oxyData) == 1: oxygenRating = int(oxyData[0], 2)
else: raise ValueError(f"Oxygen Data should only have one element, instead was {oxyData}")

if len(co2Data) == 1: co2Rating = int(co2Data[0], 2)
else: raise ValueError(f"CO2 Data should only have one element, instead was {co2Data}")

print(f"Product: {oxygenRating} * {co2Rating} = {oxygenRating * co2Rating= }")
{{< /highlight >}}
<p class="post-p">We can refactor this a bit, so that the logic of reducing the list of input values is done in a function called <code class="code">calculateRating</code>, which takes a list of data as well as a function. The function tells us, for a given digit position, what value at that position should be used to keep values in our data for our next round of culling.</p>
<p class="post-p">While we could also get a little fancy and combine <code class="code">mostCommonDigitInPosition</code> and <code class="code">leastCommonDigitInPosition</code>, I think we'd actually be in danger of making things <span class="italic">too</span> concise. The difference between <code class="code">>=</code> and <code class="code">></code> in each case is critical, and I think factoring that out might be too reductive.</p>
<p class="code-title">Day3/Part2.py (Version 2)</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    inputdata = infile.read().split('\n')

def mostCommonDigitInPosition(data, position):
    return "1" if sum([int(num[position]) for num in data]) >= len(data)/2 else "0"

def leastCommonDigitInPosition(data, position):
    return "0" if sum([int(num[position]) for num in data]) >= len(data)/2 else "1"

def calculateRating(data, digitFunc):
    for i in range(len(data[0])):
        if len(data) <= 1: break
        digitToMatch = digitFunc(data, i)
        data = [t for t in data if t[i] == digitToMatch]

    if len(data) == 1: return int(data[0], 2)
    else: raise ValueError(f"Function calculateRating should termiante with one element, instead was {data}")

oxygenRating = calculateRating(inputdata, mostCommonDigitInPosition)
co2Rating = calculateRating(inputdata, leastCommonDigitInPosition)

print(f"Product: {oxygenRating} * {co2Rating} = {oxygenRating * co2Rating= }")
{{< /highlight >}}
<div class="relative-anchor" id="day4">
    <h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2">Day 4 - Giant Squid</h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Today my biggest obstacle was, as is often the case, myself trying to be too clever and concise. <a href="https://adventofcode.com/2021/day/4">Today's challenge</a> invovled parsing a somewhat more involved text file of inputs, and then further processing that input to make it into a useful data structure. Rather than load each bingo card as a 2D array, I used the input data to create two separate arrays, one indexed by rows, the other by columns, with boards at the same position representing the same board. Determining whether a board is winning (given a list of called numbers) is a simple as asking whether any of the lines (rows or columns) in that board have all their members in the called numbers.</p>
<p class="post-p">Had I simply constructed each type of input using <code class="code">for</code> loops, this would have been fairly simply, but I wanted everything packaged up nice in a list comprehension... which took me a spell to troubleshoot and get right. Ah well.</p>
<p class="code-title">Day4/part1.py</p>
<div class="overflow-y-scroll h-124">
    {{< highlight python3 >}}
    with open ("input.txt", 'r') as infile:
        inputChunks = infile.read().split('\n\n')
    
    #---Parse the Input to make it useful----
    
    allCalledNumbers = [int(num) for num in inputChunks[0].split(',')]
    boards = [' '.join(chunk.split('\n')) for chunk in inputChunks[1:]] #get boards
    
    #Make board list of ints instead of long string by splitting every 3 characters
    intBoards = [[int(b[n:n+2]) for n in range(0, len(b), 3)] for b in boards]
    
    #boardrows is a list of boards, each of which are a list of rows in each board,
    #each of which is a list of ints
    boardRows = [[b[index:index+5] for index in range(0, 25, 5)] for b in intBoards]
    
    #boardcols is a list of boards, each of of which is a list of columns in each board,
    #each of which is a list of ints
    boardCols = [[[b[row][index] for row in range(5)] for index in range(5)] for b in boardRows]
    
    #---Define some functions to help us solve the problem as written---
    
    #For a given board (by row or column), are any of its lines made up only of numbers in 'calledNums'?
    def isBoardAWin(board, calledNums):
        return any([all([num in calledNums for num in line]) for line in board])
    
    #Score is (sum of uncalled numbers on board) * (last number called)
    def calcScore(board, calledNumbers):
        unusedNumbers = [num for line in board for num in line if num not in calledNumbers]
        return sum(unusedNumbers) * calledNumbers[-1]
    
    def doWin(board, calledNumbers):
        print(f"Score is {calcScore(b, calledSoFar)}")
        exit()
    
    #---Find solution---
    
    for i in range(len(allCalledNumbers)):
        calledSoFar = allCalledNumbers[:i]
        print(f"Searching for wins with numbers {calledSoFar}")
        winner = False
        for b in boardRows:
            if isBoardAWin(b, calledSoFar):
                print(f"Winner board by row! \n {b}")
                doWin(b, calledSoFar)
    
    
        for b in boardCols:
            if isBoardAWin(b, calledSoFar):
                print(f"Winner board by column! \n {b}")
                doWin(b, calledSoFar)
    
        print(f"No winners after {i} numbers, calling next number")
    {{< /highlight >}}
</div>
<p class="post-img-caption">Scroll to see complete code</p>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Thankfully, the infrastructure I built for part 1 of this puzzle was very useful for part to. Basically, instead of iterating through increasingly long lists of called numbers until the <span class="italic">first</span> winning is found, keep going until only 1 board has not won, recall that it's the winner, then keep adding called numbers until it does win.</p>
<p class="post-p">Since all of the setup and parsing steps are the same, I'll only include the solution finding part of the code, for brevity:</p>
<p class="code-title">Day2/Part2.py <span class="italic">(Partial)</span></p>
{{< highlight python3 "linenostart=35">}}
#---Find solution---

hasWon = [False for b in boards]

for i in range(len(allCalledNumbers)):
    calledSoFar = allCalledNumbers[:i]
    for x, b in enumerate(boardRows):
        if isBoardAWin(b, calledSoFar):
            hasWon[x] = True
            
    for x, b in enumerate(boardCols):
        if isBoardAWin(b, calledSoFar):
            hasWon[x] = True

    print(f"After calling {i} numbers,", end = " ")
    if hasWon.count(False) == 1:
        winningIndex = hasWon.index(False)
        print(f"found last board to win at index: {winningIndex}")
    elif hasWon.count(False) == 0:
        print(f"This board wins after {i} numbers called,",)
        doWin(boardCols[winningIndex], calledSoFar)
    else:
        print(f"{hasWon.count(False)} boards have not won")
{{< /highlight >}}
<div class="relative-anchor" id="day5">
    <h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2">Day 5 - Hydrothermal Venture </h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">One of the gotchas on this day is making incorrect assumptions about the ordering of points in a given line. For eaxmple, for a line with endpoints (3,5) and (3,0), doing something like: <code class="code">for y in range(point1.y, point2.y)</code> will generate exactly one point <code class="code">(3.5)</code>, because the ending y coordinate is less than the starting one. This can be fixed by either ranging over the values in a consistent direction (always from lesser to great, say) or by pre-sorting the line coordinates so that the first coordinate is always less than the second for the given axis. I chose to do the former.</p>
<p class="post-p">Unrelatedly, I'm personally a fan of <a href="https://regex101.com/">Regex101</a> for working out regexes. It makes the process of fleshing out a given pattern visual and intuitive, and the built-in reference guides and regex tips are invaluable.</p>
<p class="code-title">Day5/Part1.py</p>
<div class="overflow-y-scroll h-124">
{{< highlight python3 >}}
import re
from collections import namedtuple

with open ("input.txt", 'r') as infile:
    data = infile.read().split("\n")

Line = namedtuple('Line', ['p1x', 'p1y', 'p2x', 'p2y'])
parsedData = []
for d in data:
    reg = re.search(r'(.+),(.+) -> (.+),(.+)', d)
    parsedData.append(Line(p1x = int(reg.group(1)), p1y = int(reg.group(2)), p2x = int(reg.group(3)), p2y = int(reg.group(4))))

horizontalLines = [l for l in parsedData if l.p1y == l.p2y]
verticalLines = [l for l in parsedData if l.p1x == l.p2x]

coveredOnce, coveredMany = set(), set()

for l in horizontalLines:
    for xCoord in range(min(l.p1x, l.p2x), max(l.p1x, l.p2x)+1):
        point = (xCoord, l.p1y)
        #If the point is already covered by multiple lines, we don't need to do anything more with it, but
        if point not in coveredMany:
            #If we haven't see it at all, we should mark that we've now seen it once.
            if point not in coveredOnce:
                coveredOnce.add(point)
            #Otherwise, we should mark that we've now seen it in multiple lines
            else:
                coveredOnce.remove(point)
                coveredMany.add(point)

for l in verticalLines:
    for yCoord in range(min(l.p1y, l.p2y), max(l.p1y, l.p2y)+1):
        point = (l.p1x, yCoord)
        #If the point is already covered by multiple lines, we don't need to do anything more with it, but
        if point not in coveredMany:
            #If we haven't see it at all, we should mark that we've now seen it once.
            if point not in coveredOnce:
                coveredOnce.add(point)
            #Otherwise, we should mark that we've now seen it in multiple lines
            else:
                coveredOnce.remove(point)
                coveredMany.add(point)
                
print(f"Solution is: {len(coveredMany)}")
    {{< /highlight >}}
</div>
<p class="italic post-img-caption">Scroll to see complete code</p>
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Having selected to iterate over the points in a line in a consistent way in the first half, I felt it might be easier to pre-process the diagonal lines in the second half. That is, I swapped the endpoints of each diagonal line as necessary to ensure the point with the lower X coordinate was first. Then, if the second y coordinate is great  than the first, each time we increase the x coordinate by 1, we will by definition incrase the y coordinate by 1. If the second y coordinate is less than the first, y decreased by 1 for each increase of the x coordinate. Other than that, the processing of each point to see if it's been covered already is the same as in part one.</p>
<p class="post-p">For brevity, I've only included the addititional processing necessary for part 2 of today's challenge.</p>
<p class="code-title">Day5/Part2.py <span class="italic">(Partial)</span></p>
{{< highlight python3 "linenostart=44">}}
diagonalLines = [l for l in parsedData if l not in verticalLines and l not in horizontalLines]

for l in diagonalLines:
    #Make sure the first coordinate of each line is left of the second coordinte
    if l.p2x < l.p1x: l = Line(p1x = l.p2x, p1y = l.p2y, p2x = l.p1x, p2y = l.p1y)
    #Determine if y increases or descreases with increasing X
    yDir = 1 if l.p2y > l.p1y else -1

    for yDelta, xCoord in enumerate(range(l.p1x, l.p2x+1)):
        point = (xCoord, l.p1y + (yDelta*yDir))

        if point not in coveredMany:
            #If we haven't see it at all, we should mark that we've now seen it once.
            if point not in coveredOnce: 
                coveredOnce.add(point)
            #Otherwise, we should mark that we've now seen it in multiple lines
            else:
                coveredOnce.remove(point)
                coveredMany.add(point)

print(f"Solution is: {len(coveredMany)}")
{{< /highlight >}}
<div class="relative-anchor" id="day6">
    <h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2">Day 6 - Lanternfish</h2>
</div>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Part one of <a href="https://adventofcode.com/2021/day/6">today's puzzle</a> was deceptively simple. It asks the challenger to calculate the number of lanternfish present after a given number of steps of an iterative process. The way the puzzle's data is displayed in the examples presented, one might be tempted to keep the data as a long list of individual fish listed by the number of days till they next reproduce; then, for each step, iterate over the list and take the appropriate action. While this shold generate a solution, the list would quickly balloon out of the control. The key insight is that each fish that will, say, generate a new fish in 4 days, is identical to every other fish that will spawn a new fish in four days. So really, we don't need to track individual fish, just the total count of fish that will reproduce in a given number of days. For every day that passes, each of those counts of fish reduce their count by one, and we do some special accounting to the fish that are reproducing today, and iterate.</p>
<p class="post-p">This quick and simple approach does make one worry that part 2 will require more convoluted reasoning though.</p>
<p class="code-title">Day6/Part1.py</p>
{{< highlight python3 >}}
with open("input.txt", "r") as infile:
    inputdata = [int(num) for num in infile.read().split(',')]

fishcounts = [inputdata.count(num) for num in range(0,8+1)]
daysToRun = 80

for _ in range(daysToRun):
    newfishcounts = fishcounts[1:] + [fishcounts[0]]
    newfishcounts[6] += fishcounts[0]
    fishcounts = newfishcounts

print(f"After {daysToRun} days there are {sum(fishcounts)} lanternfish")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Ah! We've gotten lucky here and avoided the 'gotcha' that the puzzle writer was thinking of. The second step asks to calculate the number of fish present after 256 steps; if one had taken the "process the whole list" technique in part one, one would be screwed in part two as the exponential growth of the fish population really takes off. But with a condensed, iterative process like we used in part 1, one only has to change the <code class="code">daysToRun</code> value to 256, and our answer pops out in less than a quarter of a second! Excellent. I'm not even going to include the code a second time, since it is <span class="italic">identical to part 1 except for the value of <code class="code">daysToRun</code></span>.</p>
<p class="code-title">Day6/Part2.py</p>
{{< highlight python3 >}}
#See Day6/Part1.py, above
{{< /highlight >}}


<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2 relative-anchor" id="day7">Day 7 - The Treachery of Whales </h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Just to humblebrag a bit (well, really, to brag; but hey, it's my website), I solved part 1 of day's challenge in the shower. My reasoing went something like the following:</p>
<ul class="post-ul">
    <li>We're looking to select a point <img src="xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> that minimizes the function <img src="day7/p1mineq.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300">, as presented in problem setup.</li>
    <li>Taking the derivative of this sum is somewhat complicated, but there's actually a better way to reason about it.</li>
    <li>Looked at another way, we're looking to find a point <img src="day7/xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> such that moving that point will only cause the total crab-distance traveled to increase; a local minimum.</li>
    <li>Picture our point where our crabs our converging at a point <img src="x.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> on the number line, with <img src="day7/n.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> crabs less than x and <img src="day7/totalcrabsminusn.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> crabs great than <img src="x.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> </li>
    <li>As we slide our alignment point along the number line in a continuous fashion, if it moves a small distance <img src="day7/deltax.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> in, say the positive direction:
        <li class="pl-8">We add <img src="day7/ndeltax.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> units of additional crab travel, as we move further from the crabs at positions less than our alignment point, but</li>
        <li class="pl-8">We subtract <img src="day7/totalcrabsub.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> as we move closer to the crabs greater than our alignment point</li>
    </li>
    <li>And similarly, if <img src="day7/deltax.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> is negative, we get closer to <img src="n.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> crabs and futher from <img src="day7/totalcrabsminusn.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> crabs.</li>
    <li>So, if <img src="day7/ngreater.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300">, increasing <img src="day7/xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> will cause the total crab distance to descrease. And if <img src="day7/nless.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300">, decreasing <img src="xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> with cause thte total crab distance to increase.</li>
    <li>But recall, what we want is to find a point where neither of those things is true; where <img src="day7/xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> is at a mimumum, so any movement of it causes the total crab distance to incerase. This is only true where neither of the above inequalities is statisfied, i.e. when <img src="day7/nequal.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300">.</li>
    <li>Moving some terms around, we find that the total crab distance travelled is at a mimimum when <img src="day7/div2.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300">, in other words, when the number of crabs greater than and less than the alignment point are equal. This is true when <img src="day7/xalign.gif" alt="" class="inline-block px-1 py-0.5 bg-gray-300"> is the median of the crab points.</li>
</ul>
<p class="post-p">All that thinking in a warm shower yeilded a very short (and working) bit of code.</p>
<p class="code-title">Day7/Part1.py</p>
{{< highlight python3 >}}
from statistics import median

with open("input.txt", "r") as infile:
    data = [int(num) for num in infile.read().split(',')]

median = median(data)
minFuel = sum([abs(d-median) for d in data])

print(f"{minFuel= }")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Sadly, my brain failed me when trying to come up with a similarly clever solution for part 2, so I ended up implementing the crab-fuel-expenditure function as described in the problem statement and iteratively increasing and decreasing the alignment point value until a minimum was found. I had the code start at the median value of the list, somewhat arbitrarily, but the code still finishes in under a quarter of a second and yields the correct answer.</p>
<p class="post-p">I skipped a couple of obvious optimizations. 
    <ul class="pb-6 post-ul">
        <li>Incrementing the position that we're currently testing the crab-distance of by only 1 unit each time probably isn't optimal (for my inputs, I had to evaluate 140 positions before finding a minimum). Perhaps some variation on Newton's method could have been used to estimate a better delta for <code class="code">testVal</code>?</li>
        <li>There might be a more ideal value to start the search at (the mean perhaps?).</li>
    </ul>
</p>
<p class="code-title">Day7/Part2.py</p>
<div class="overflow-y-scroll h-124">
    {{< highlight python3 >}}
    from statistics import median
    
    with open("input.txt", "r") as infile:
        data = [int(num) for num in infile.read().split(',')]
    
    def fuelUsed(crabPositions, position):
        return sum([(abs(d - position)*(abs(d-position)+1)/2) for d in crabPositions])
    
    class lazyDict(dict):
        def __init__ (self, factory):
            self.factory = factory
        def __missing__ (self, key):
            self[key] = self.factory(key)
            return self[key]
    
    fuelToReach = lazyDict(lambda x: fuelUsed(data, x))
    
    med = median(data)
    fuelToReach[med] = fuelUsed(data, med)
    testVal = med
    
    while not ((fuelToReach[testVal] < fuelToReach[testVal+1]) and (fuelToReach[testVal] < fuelToReach[testVal-1])):
        if fuelToReach[testVal-1] < fuelToReach[testVal]: testVal -= 1
        elif fuelToReach[testVal+1] < fuelToReach[testVal]: testVal += 1
        else: raise ValueError(f"Something has gone wrong\n {fuelToReach= }")
    
    print(f"Minimum required fuel is reached at position {testVal} with {fuelToReach[testVal]} fuel used")
    print(f"Calculated {len(fuelToReach)} potential positions")
    
    
    
    {{< /highlight >}}
</div>
<p class="post-img-caption">Scroll to see full code</p>
<!--
<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-128 post-h2 relative-anchor" id="day2">Day XXX - XXX </h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Enim adipisicing nostrud in velit nisi anim aliquip nostrud duis officia do elit veniam irure.</p>
<p class="code-title">DayXXX/Part1.py</p>
{{< highlight python3 >}}
#some code here
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Mollit voluptate tempor cillum amet cillum incididunt nisi.</p>
<p class="code-title">DayXXX/Part2.py</p>
{{< highlight python3 >}}
#Some Code Here
{{< /highlight >}}
-->