---
title: "Advent of Code 2021"
date: 2021-11-30T02:30:42-05:00
draft: false
tags:
- codeadvent
- codeadvent2021
- python
slug_image: 1200px-Python-logo-notext.png
---
<p class="post-p">Is it Advent of Code time again? Well, here goes nothing. Let's see wha we can cook up.</p>
<p class="post-p">I'm planning on completing most (all) of this year's challenges in Python, <a href="/post/advent-of-code-2020/">same as last year</a>.</p>
<div class="w-auto pt-2 pb-4 pl-2 mr-2 -ml-2 align-top bg-gray-200 md:w-98">
    <p class="text-2xl">Table of Contents</p>
    <div class="ml-8 font-semibold">
        <p><a href="#day1">Day 1 - Sonar Sweep</a></p>
        <p><a href="#day2">Day 2 - Dive!</a></p>
    </div>
</div>
<h2 class="table-cell w-auto pb-1 border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day1">Day 1 - Sonar Sweep</h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">I feel like it's Advent of Code tradition for me to read in the input from file (as strings) and try to do comparisons on it like ints, forgetting to cast them to intergers. Which means I was comparing textually, instead of numerically, so my answer was off by <span class="italic">two</span>. Absurd. </p>
<p class="post-p">You really could do <a href="https://adventofcode.com/2021/day/1">today's challenge</a> entirely in one line, but I think it's slightly more readable broken up as I've done. Here's the complete code:</p>
<p class="code-title">Day1/Part1.py</p>
{{< highlight python3 "hl_lines=2">}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

numDecreases = len([pair for pair in zip(data[:-1], data[1:]) if pair[0] < pair[1]])

print(f"{numDecreases=}")
{{< /highlight >}}
<p class="post-img-caption">The offending line, where I remembered to cast the input to ints.</p>
<h4 class="pt-4 pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Part 2 could also probably be inlined, but the list-comprehension-within-list-comprehension is, again, not the most readable thing, I think. Breaking out the three key steps (creating triples of the data, finding their sums, and finding where adjacent sums are decreasing) into 3 lines of code I think makes the solution more parsable.</p>
<p class="code-title">Day1/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", "r") as infile:
    data = [int(t) for t in infile.read().split('\n')]

triples = zip(data[:-2], data[1:-1], data[2:])
windowSums = [sum(list(t)) for t in triples]

numDecreases = len([t for t in zip(windowSums[:-1], windowSums[1:]) if t[0] < t[1]])

print(f"{numDecreases=}")

{{< /highlight >}}
<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day2">Day 2 - Dive!</h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-">The first part of today's challenge has us dealing with a list of things that happen sequentially (tracking the horizontal and vertical movements of our submarine), but the answer only has to do with summing them in some specific ways. This smells strongly of a 'gotcha' coming in part 2 - if we can the easy, just-sum-it-up route for part 1, we won't be able to reuse any code for part 2 when the order actually matters. But that's alright, I guess, we'll take the easy route on this one.</p>
<p class="post-p">There's a fair amount of repetition in my list comprehensions here, but for a 7-line program I don't terribly feel like factoring it out.</p>
<p class="code-title">Day2/Part1.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal = sum([step[1] for step in data if step[0] == 'forward'])
depth = sum([step[1] for step in data if step[0] == 'down']) - sum([step[1] for step in data if step[0] == 'up'])
print(f"Solution product is {horizontal * depth =}")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">As expected, we're paying the (small) price for not doing the first part iteratively. That's alright, we can implement it now.</p>
<p class="post-p">This does give me a chance to play with a new feature of Python 3.10: structural pattern matching. It's like a switch-case structure on steroids. To make sure I'm running this code in Python 3.10 specifically, I'll use pipenv to lock the version to 3.10.0 by running <code class="code">pipenv install --python 3.10</code> on the command line.</p>
<p class="post-p">Our code is ultimately fairly simple; thankfully, I encountered no "unmatched instruction" errors, which means I parsed the input correctly.</p>
<p class="code-title">Day2/Part2.py</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    # data is a list of tuples; each tuple is of form ('instruction', int) where 'instruction' is forward, down, up
    data = [(line.split(' ')[0], int(line.split(' ')[1])) for line in infile.read().split('\n')]

horizontal, depth, aim = 0,0,0

for d in data:
    match d:
        case ('down', num):
            aim += num
        case ('up', num):
            aim -= num
        case ('forward', num):
            horizontal += num
            depth += aim * num
        case _:
            raise ValueError(f"Unmatched instruction {d}")

print(f"Solution is {horizontal*depth= }")
{{< /highlight >}}
<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day2">Day 3 - Binary Diagnostic </h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Ah, day 3 of Advent of Code, where we traditionally get into nested-processing, working with binary, and parsing numbers based on their digits. I don't know that this literally happens on day 3 every year, but it seems a familiar progression in the early days of an Advent of Code challenge. My first thought is - let's make sure we iterate through the entire input as few times as possible, something made easier by the fact that epsilon and gamma are, in some sense, complements of each other.</p>
<p class="post-p">This one's not too hard - using a <code class="code">defaultdict</code> from the <code class="code">collections</code> module makes the process of adding up the number of "1"'s in all the input numbers a little cleaner.</p>
<p class="code-title">Day3/Part1.py</p>
{{< highlight python3 >}}
from collections import defaultdict

with open("input.txt", 'r') as infile:
    data = infile.read().split('\n')

numInputs = len(data)
onesCount = defaultdict(lambda: 0)

#Count the number of "1"'s at each digit position in all of the input numbers
for num in data:
    for i, digit in enumerate(num):
        onesCount[i] += int(digit)

#Calculate gamma, epison as lists of strings ("1" and "0")
gamma = [("1" if onesCount[i] > (numInputs / 2) else "0") for i in range(len(onesCount))]
epsilon = [("1" if gamma[i] == "0" else "0") for i in range(len(onesCount))]

#Concatenate lists, as 0b to represent binary, cast to int
result = int('0b' + ''.join(gamma), 2) * int('0b' + ''.join(epsilon), 2)
print(f"{gamma= } {epsilon= } {result= }")
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Now we're moving into the realm of processing some input data with multiple passes, while restricting which data is in each pass based on our processing of previous steps. My initial solution was a little cumbersome, but I think gets the intention accross pretty well. </p>
<p class="code-title">Day2/Part2.py (Version 1)</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    inputdata = infile.read().split('\n')

def mostCommonDigitInPosition(data, position):
    return "1" if sum([int(num[position]) for num in data]) >= len(data)/2 else "0"


oxyData = [d for d in inputdata]
co2Data = [d for d in inputdata]

#find Oxygen Rating
for i in range(len(inputdata[0])):
    if len(oxyData) <= 1: break
    MCD_o2 = mostCommonDigitInPosition(oxyData, i)
    oxyData = [t for t in oxyData if t[i] == MCD_o2]

#find CO2 Rating
for i in range(len(inputdata[0])):
    if len(co2Data) <= 1: break
    MCD_co2 = mostCommonDigitInPosition(co2Data, i)
    co2Data = [t for t in co2Data if t[i] != MCD_co2]

if len(oxyData) == 1: oxygenRating = int(oxyData[0], 2)
else: raise ValueError(f"Oxygen Data should only have one element, instead was {oxyData}")

if len(co2Data) == 1: co2Rating = int(co2Data[0], 2)
else: raise ValueError(f"CO2 Data should only have one element, instead was {co2Data}")

print(f"Product: {oxygenRating} * {co2Rating} = {oxygenRating * co2Rating= }")
{{< /highlight >}}
<p class="post-p">We can refactor this a bit, so that the logic of reducing the list of input values is done in a function called <code class="code">calculateRating</code>, which takes a list of data as well as a function. The function tells us, for a given digit position, what value at that position should be used to keep values in our data for our next round of culling.</p>
<p class="post-p">While we could also get a little fancy and combine <code class="code">mostCommonDigitInPosition</code> and <code class="code">leastCommonDigitInPosition</code>, I think we'd actually be in danger of making things <span class="italic">too</span> concise. The difference between <code class="code">>=</code> and <code class="code">></code> in each case is critical, and I think factoring that out might be too reductive.</p>
<p class="code-title">Day3/Part2.py (Version 2)</p>
{{< highlight python3 >}}
with open("input.txt", 'r') as infile:
    inputdata = infile.read().split('\n')

def mostCommonDigitInPosition(data, position):
    return "1" if sum([int(num[position]) for num in data]) >= len(data)/2 else "0"

def leastCommonDigitInPosition(data, position):
    return "0" if sum([int(num[position]) for num in data]) >= len(data)/2 else "1"

def calculateRating(data, digitFunc):
    for i in range(len(data[0])):
        if len(data) <= 1: break
        digitToMatch = digitFunc(data, i)
        data = [t for t in data if t[i] == digitToMatch]

    if len(data) == 1: return int(data[0], 2)
    else: raise ValueError(f"Function calculateRating should termiante with one element, instead was {data}")

oxygenRating = calculateRating(inputdata, mostCommonDigitInPosition)
co2Rating = calculateRating(inputdata, leastCommonDigitInPosition)

print(f"Product: {oxygenRating} * {co2Rating} = {oxygenRating * co2Rating= }")
{{< /highlight >}}

<!--
<h2 class="table-cell w-auto h-20 pb-1 align-bottom border-b-4 border-gray-200 md:w-96 post-h2 relative-anchor" id="day2">Day XXX - XXX </h2>
<h4 class="pt-4 pb-1 border-b-2 border-gray-200 post-h4 w-72">Part 1</h4>
<p class="post-p">Enim adipisicing nostrud in velit nisi anim aliquip nostrud duis officia do elit veniam irure.</p>
<p class="code-title">DayXXX/Part1.py</p>
{{< highlight python3 >}}
#some code here
{{< /highlight >}}
<h4 class="pb-1 mt-4 border-b-2 border-gray-200 post-h4 w-72">Part 2</h4>
<p class="post-p">Mollit voluptate tempor cillum amet cillum incididunt nisi.</p>
<p class="code-title">DayXXX/Part2.py</p>
{{< highlight python3 >}}
#Some Code Here
{{< /highlight >}}
-->
