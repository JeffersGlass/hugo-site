---
title: "What's New in Pyscript 2022.12.1"
date: 2022-12-06T08:12:48-05:00
draft: true
tags:
- Python
- PyScript
- Pyodide
- JavaScript
description: "The big changes in PyScript version 2022.12.1"
slug_image: py_2022_12_1_featured.png
---
<p class="text-4xl bg-red-200">JEFF JEFF JEFF POINT THE PYSCRIPT LINKS ON THIS PAGE TO THE NEW RELEASE</p>
<style>
    code:not(.nocode):not(.language-python){
        --tw-text-opacity: 1;
        color: rgba(5, 120, 85, var(--tw-text-opacity));
    }
    .py-terminal{
        min-height: 10em;
        background-color: black;
        color: white;
    }
    .py-pop-up {
    text-align: center;
    width: 600px;
    }

    .py-pop-up p {
        margin: 5px;
    }

    .py-pop-up a {
        position: absolute;
        color: white;
        text-decoration: none;
        font-size: 200%;
        top: 3.5%;
        right: 5%;
    }

    /* Pop-up second layer end */
    .alert-banner {
        position: relative;
        padding: .5rem 1.5rem .5rem .5rem;
        margin: 0.5rem 2rem;
    }

    .alert-banner p {
        margin: 0;
    }

    .py-error{
        background-color: #FFE9E8;
        border: solid;
        border-color: #f0625f;
        color: #9d041c;
    }

    .py-warning {
        background-color: rgb(255, 244, 229);
        border: solid;
        border-color: #ffa016;
        color: #794700;
    }

    .alert-banner.py-error>#alert-close-button {
        color: #9d041c;
    }

    .alert-banner.py-warning>#alert-close-button {
        color: #794700
    }

    #alert-close-button {
    position: absolute;
    right: .5rem;
    top: .5rem;
    cursor: pointer;
    background: transparent;
    border: none;
}
</style>


<script>    
    //Create Load PyScript buttons:
    document.addEventListener('DOMContentLoaded', () => {
        btn_locations = document.getElementsByClassName('load-pyscript')
        Array.from(btn_locations).forEach(div => {
            div.classList.add('my-2', 'mx-8', 'border-blue-200', 'rounded-xl', 'flex', 'flex-row', 'justify-center', 'w-auto', "py-1")
            let p = document.createElement('p')
            p.classList.add('my-auto', 'mr-4', 'italic')
            p.innerText = "Want to run these examples live in your browser?"
            div.appendChild(p)
            //button
            let btn = document.createElement('button')
            btn.innerText = "Load PyScript"
            btn.classList.add('load-pyscript-button')
            btn.onclick = loadPyScript
            div.appendChild(btn)
        });
    })
    function setupLoadButtons(){

    }
    function loadPyScript() {
        //load css
        css_link = document.createElement("link")
        css_link.rel = "stylesheet"
        css_link.type = "text/css"
        //css_link.href = "https://pyscript.net/unstable/pyscript.css"
        //css_link.href = "http://127.0.0.1:5501/pyscriptjs/build/pyscript.css"
        css_link.href = "./pyscript.css"
        document.getElementsByTagName('head')[0].appendChild(css_link)

        //load cs
        script_tag = document.createElement('script')
        //script_tag.src = "https://pyscript.net/unstable/pyscript.js"
        //script_tag.src = "http://127.0.0.1:5501/pyscriptjs/build/pyscript.js"
        script_tag.src = "./pyscript.js"
        document.body.append(script_tag)        
    }
    document.addEventListener('pyscript_ready', () => {
        static = document.getElementsByClassName('static-example')
        live = document.getElementsByClassName('live-example')
        Array.from(static).forEach(div => {
            div.classList.add('hidden')
        })
        Array.from(live).forEach(div => {
            div.classList.remove('hidden')
        })
        load_buttons = document.getElementsByClassName('load-pyscript')
        Array.from(load_buttons).forEach(elem => {
            elem.classList.add('hidden')
        })
    })
</script>
<py-script class="hidden">
    import js
    loaded_event = js.Event.new('pyscript_ready')
    js.document.dispatchEvent(loaded_event)
</py-script>
<p class="post-p">Another couple months have flown by, and PyScript has a shiny new release: <a href="https://pyscript.net/releases/2022.12.1" class="bg-red-200">PyScript Version 2022.12.1 is now live!</span>.</p>
<p class="bg-red-200 post-p">For those who want to get <span class="italic">really</span> in the weeds, I've prepared <a href="">a granular changelog of every Issue and Pull Request since the last release</a>. It was made possibly by a (slightly tweaked) version of Ned Batchelder's <a href="https://github.com/nedbat/dinghy">Dinghy GitHub digest tool</a> </p>
<p class="post-p">What's <span class="italic">not</span> covered here in depth are some of the amazing things built with or adjacent to PyScript. In particular, if you haven't seen the <a href="https://pyscript.net/tech-preview/micropython/">technical preview of MicroPython running in the Browser</a> or <a href="https://pyviz-dev.github.io/panel/user_guide/Running_in_Webassembly.html">running Panel apps in the browser</a> with <code>panel convert</code>, you absolutely must. But those deserve their own writeups, and this post will focus on the PyScript release itself.</p>
<p class="post-p">Now is a great time to remind users that, for consistent long term bevahior, I recommend projects link to pinned releass like <code class="code">https://pyscript.net/releases/2022.12.1/pyscript.js</code>, and not to <code class="code">/latest/pyscript.js</code>. If your project links to <code class="code">/latest</code>, all the improvements in the new release have almost certainly broke it. Pinned releases are the way to go, and there's talk of deprecating/removing <code class="code">/latest</code> in the near future.</p>
<div id="TOC" class="grid justify-center p-1 m-auto bg-gray-200">
    <span>Jump To: <span>
    <a href="#Display">display()</a> • 
    <a href="#paths">[[fetch]]</a> • 
    <a href="#PyScript">PyScript</a> • 
    <a href="#infrastructure">Infrastructure</a> • 
    <a href="#pyodide">Pyodide</a> • 
    <a href="#Community">Community</a> • 
    <a href="#Team">The PyScript Team</a> • 
    <a href="#Next">What's Next?</a>
</div>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="Display"><code class="text-green-600">display()</code>, <code>&lt;py-terminal&gt;</code>, and <code>stdout</code></h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200"><code>display()</code></h4>
<p class="post-p">There's one change to the PyScript API that's so big, it's getting its own whole section! And it has to do with how PyScript outputs to the browser window. <span class="font-bold"><code>print()</code> no longer outputs to arbitrary places in the browser window!</span> The new function to use is called <span class="font-bold"><code>display()</code></span>. And using <code>print()</code> has some new and interesting behaviors as well.</p>
<p class="post-p">In "desktop flavored" Python, <code>print()</code> takes the <code>*objects</code> it's given, converts them to strings <a href="https://docs.python.org/3/library/functions.html#print">"like <code>str()</code> does"</a>, and sends the results to <code class="code">sys.stdout</code>. <code>sys.stdout</code> is a File-like object with methods like <code>read()</code>, <code>readline()</code>, <code>write()</code>, and so on. It represents a continuous stream of text, plus the idea that various characters break up the stream into "lines." And that's about it. The simplicity of this default output stream is its power - a very similar structure can be used to represent a stream of text into a file, over a network, a buffer, etc.</p>
<p class="post-p">Prior to 2022.12.1, Python's <code>sys.stdout</code> was routed <span class="italic">to the DOM</span> via fairly complicated <a href="https://github.com/pyscript/pyscript/blob/beb3aa157419ecb53863c76674069c78cb48dfe1/pyscriptjs/src/python/pyscript.py#L368-L419">wrapper setup</a>. However, a browser window has so many more dimensions of possibility for where we might want to place content compared to a terminal. Thus, the metaphor of "use <code>print()</code> and we'll just send some version of that stream to a location on the page" wasn't as useful as it could be.</p>
<p class="post-p">As of 2022.12.1, <span class="font-bold"><code>print()</code> (i.e. stdout) goes to the developer console; <code>display()</code> is for outputting to the browser window</span> (<a href="https://github.com/pyscript/pyscript/pull/749">#749</a>)</p>
<div class="py-2 pl-2 m-0 ml-4 bg-green-100">
    <h4 class="text-xl"><code class="nocode" >display(*values, target=None, append=True)</code></h4>
    <div class="ml-4">
        <p class="pt-1 text-justify"><span class="font-bold">*values</span> (<code>list</code>) - the list of objects to be displayed. Can be any of the following MIME types:: "text/plain", "text/html", "image/png", "image/jpeg", "image/svg+xml", "application/json" or "application/javascript"</p>
        <p class="pt-1 mt-2 text-justify"><span class="font-bold">target</span> (<code>str</code>)- the ID of the html tag to output to. If <code>none</code>, output to the current <code>&lt;py-script&gt;</code> tag.</p>
        <p class="pt-1 mt-2 text-justify"><span class="font-bold">append</span> (<code>boolean</code>) if the output is going to be appended or not to the `target`ed element. It creates a <code>&lt;div&gt;</code> tag if <code>True</code> and a <code>&lt;py-script&gt;</code> tag with a random ID if <code>False</code></p>
    </div>
</div>
<p class="post-p">If <code>display()</code> is given a <code>target</code> argument, it will attempt to send its *values to the HTML element on the page with that ID. If not, it will use the currently executing tag (&lt;py-script&gt; or &lt;py-repl&gt;) as that destination. Either way, the content is placed either in a new &lt;div&gt; as a sibling of the currently executing tag, or replace the content at the tag location, depending on whether `append` is true or false.</p>
<p class="post-p">So for example, in place of the usual <code>print("Hello, world")</code>, one could do one of these (they have slightly different behaviors - try them out!):</p>
<div class="p-2 mx-4 my-2" style="background-color: #f0f3f3">
{{< highlight "python" "linenos=false" >}}
display("Hello World")

display("Hello")
display("World")

display("Hello")
display("World", append=False)

display("Hello world", target="target-div")
{{< /highlight >}}
</div>
<div class="hidden live-example">
    <div class="grid grid-cols-1 md:grid-cols-2 md:gap-x-2">
        <div>
            <py-repl>display("Hello World")</py-repl>
            <py-repl>
                display("Hello")
                display("World")
            </py-repl>
            <py-repl>display("Hello", "World", append=False)</py-repl>
            <py-repl>display("Hello world", target="target-div")</py-repl>
        </div>
        <div class="pt-1 pl-2 bg-gray-200">
            <p class="text-sm text-gray-700">#target-div</p>
            <div id="target-div"></div>
        </div>
    </div>
</div>
<div class="load-pyscript"></div>
<p class="post-p"><code>display()</code> escapes any HTML given to it as an input string, so <code>display("&lt;br&gt;")</code> prints the literal characters <code class="code">&lt;br&gt;</code> to the screen, instead of creating a newline. For non-string inputs, <code>display(some_obj)</code> calls <code>repr(some_obj)</code> and escapes that. If you <span class="italic">do</span> want to inject HTML into your page, a new object is to use the new <a href="https://github.com/pyscript/pyscript/blob/515858f3134bf031497f0420e8a0e7fbc4c32be0/pyscriptjs/src/python/pyscript.py#L49">HTML class</a> (<a href="https://github.com/pyscript/pyscript/pull/915">#915</a>):</p>
<div class="">
<p class="code-title">HTML Class</p>
{{< highlight "python3" >}}
display("<p>You'll see the angle brackets and everything here</p>")
display(HTML("<p><b>But this is an honest-to-goodness bold paragraph!</b></p>"))
{{< /highlight >}}
</div>
<div class="hidden my-3 live-example">
    <py-repl>
        display("<p><b>You'll see the angle brackets and everything here</b></p>")
        display(HTML("<p><b>But this is an honest-to-goodness bold paragraph!</b></p>"))
    </py-repl>
</div>
<div class="load-pyscript"></div>
<p class="post-p">As part of this reshaping of output, the <span class="font-semibold"><code>&lt;py-script output="..."&gt;</code> attribute has been deprecated...</span> at least for now. This means that if you want the stdout of your code to go to a specific place in the browser window, you'll need to handle that on the Python side. One possible way would be to use <code><a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout">contextlib.redirect_stdout</a></code>, but there are many ways to handle that behavior. (<a href="https://github.com/pyscript/pyscript/pull/981">#981</a>)</p>
<p class="post-p">Finally, it's worth nothing that the behavior of placing content based on the currently executing tag doesn't necessarily work for coroutines in async contexts. In most situations, you'll see a helpful warning banner will let you know:</p>
<p class="flex justify-center post-p"><code class="px-2 text-gray-800 text-red-800 border-2 border-red-800 nocode">Implicit target not allowed here. Please use display(..., target=...)</code></p>
<p class="post-p">But due to some tricky edge cases with how warnings percolate up from coroutines, things currently may just fail silently.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200"><code>&lt;py-terminal&gt;</code></h4>
<p class="post-p">So if <code>display()</code> is for writing to the screen, what does <code>print()</code> do? Well, a couple of things, but most visibly, it writes to the <code>&lt;py-terminal&gt;</code></p>
<div class="mx-0 static-example md:mx-4">
<p class="code-title">hello_world_terminal.py</p>
{{< highlight "python3" >}}
print("Hello, world!")
for i in range(5):
    print(f"I can count to {3}")
{{< /highlight >}}
<pre class="px-4 py-2 mt-2 py-terminal" >Hello, world!<br>I can count to 0<br>I can count to 1<br>I can count to 2<br>I can count to 3<br>I can count to 4<br></pre>

</div>
<div class="hidden live-example">
    <py-script>
        print("Hello, world!")
        for i in range(3):
            print(f"I can count to {i}")
    </py-script>
    <div class="w-full md:w-5/6 md:m-auto gap-y-4">
        <py-repl>
        print("Hello, world!")
        for i in range(3):
            print(f"I can count to {i}")
        </py-repl>
        <div class="px-4 py-2 bg-black">
            <py-terminal></py-terminal>
        </div>
    </div>
</div>
<div class="load-pyscript"></div>
<p class="post-p">The <code>&lt;py-terminal&gt;</code> achieves a couple things:</p>
<ul class="post-ul">
    <li>It makes sure that output to stdout goes <span class="italic">somewhere</span> visible; if you copy and paste Python code from your desktop environment to the browser, you can see at least something happening</li>
    <li>If you want to use a terminal-like output for your code, this is a pre-made solution</li>
</ul>
<p class="post-p">The behavior and placement of the <code>&lt;py-terminal&gt;</code> is configurable via a new <a href="https://docs.pyscript.net/latest/reference/plugins/py-terminal.html">terminal setting</a> in <code>&lt;py-config&gt;</code>. The options are:</p>
<table class="w-full md:w-3/4 md:m-auto">
    <thead>
        <tr>
            <th>value</th>
            <th>description</th>
        </tr>
    </thead>
    <tbody>
        <tr class="divide-x-2 divide-gray-400">
            <td class="pl-2 pr-4"><code>&quot;auto&quot;</code></td>
            <td class="pl-4 pr-2">(default) Automatically add a <code>&lt;py-terminal auto&gt;</code>, to the page. The terminal is initially hidden and automatically shown as soon as something writes to <code>stdout</code> and/or <code>stderr</code></td>
        </tr>
        <tr class="divide-x-2 divide-gray-400">
            <td class="pl-2 pr-4"><code>true</code></td>
            <td class="pl-4 pr-2">Automatically add a visible <code>&lt;py-terminal&gt;</code> to the page when PyScript loads. It will be added to the end of the &lt;body&lt; unless there is a <code>&lt;py-terminal&gt;</code> tag on the page.</td>
        </tr>
        <tr class="divide-x-2 divide-gray-400">
            <td class="pl-2 pr-4"><code>false</code></td>
            <td class="pl-4 pr-2">Don&#39;t add <code>&lt;py-terminal&gt;</code> to the page</td>
        </tr>
    </tbody>
</table>
<p class="post-p">So, if you want to stick the terminal somewhere specific, simply include <code>&lt;py-terminal&gt;&lt;/py-terminal&gt;</code> on your page. You can even include several py-terminals - output to <code>stdout</code> will be sent to all of them.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">stdout in the Developer Console</h4>
<p class="post-p">In addition to going to <code>&lt;py-terminal&gt;</code>, writes to <code>stdout</code> also go to the <a href="https://support.monday.com/hc/en-us/articles/360002197259-How-to-open-the-developer-console">Developer Console</a>. This is the closest analog in the browser to a "dumb terminal", and so it makes a certain amount of sense for <code>stdout</code> to be routed there.</p>
<p class="post-p">There are certain small differences, since of course the dev console <span class="italic">isn't</span> a terminal. For instance, we discovered just the other day that <code>console.log()</code> (which is used to write to the dev console) <a href="https://github.com/pyscript/pyscript/issues/472#issuecomment-1281228942">doesn't output unless it receives a newline</a>. So something like <code class="code">print("Hello world", end = "")</code> won't show up until you log something else with a newline in it! But for simple debugging purposes, or for output where (even temporarily) including a <code>&lt;py-terminal&gt;</code> on the page would be untenable, this is a great addition.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Remarks</h4>
<p class="post-p">If I were a betting man, I'd hedge that the API for <code>display()</code> is likely to continue to change and evolve. It's a brand-new and breaking feature, and I suspect its semantics are going to continue to get tweaked. If you find more issues or inconsistencies, be sure to <a href="https://github.com/pyscript/pyscript/issues">raise an issue on GitHub</a> or come tell us about it <a href="https://discord.gg/CQU2Qyeb">on the PyScript Discord</a>.</p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="paths">Fetching Files with <code>&lt;py-config&gt; [[fetch]]</code></h4>
<p class="post-p">Previously, all files listed in <code>&lt;py-config&gt; paths:</code> were <code>fetch()</code>'d from the listed URLs and dropped into the embedded filesystem in the same folder as the running Python Script. Which is to say, pointing a path to the relative URL <code class="code">'data/files/Feb-24/info.txt'</code> would make that file available via <code class="code">with open('info.txt')... </code>.</p>
<p class="post-p"><span class="font-semibold">From PyScript 2022.12.1, <code>&lt;py-config&gt; paths:...</code> has been replaced by <code>&lt;py-config&gt;</code> [[fetch]] ...</span>, and it's much more powerful that its predecessor.</p>
<p class="post-p">The new options allow the user to fetch multiple files ina  way that preserves their URL/directory structure. The parameters are all bundled in a "fetch configuration" table under the <code>&lt;py-config&gt;</code> tag; you can have multiple fetch configurations in a single py-config.</p>
<p class="post-p">The options for a fetch config are:</p>
<table class="w-full m-2 md:w-3/4 md:m-auto">
    <tr class="font-bold">
        <td>Value</td>
        <td>Type</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>`from`</td>
        <td>string</td>
        <td>Base URL for the resource to be fetched.</td>
    </tr>
    <tr>
        <td>`to_folder`</td>
        <td>string</td>
        <td>Name of the folder to create in the filesystem.</td>
    </tr>
    <tr>
        <td>`files`</td>
        <td>List of string</td>
        <td>List of files to be downloaded. Cannot be combined with "to_file"</td>
    </tr>
    <tr>
        <td>`to_file`</td>
        <td>string</td>
        <td>Name of the target to create in the filesystem. Cannot be combined with "files"</td>
    </tr>
</table>
<p class="post-p">Breaking that down a bit, here's how I personally think through which parameters to use:</p>
<ul class="py-4 pl-8 text-justify list-disc list-outside">
    <li><code>files</code> vs <code>to_file</code>:</li>
    <ul class="py-2 pl-8 text-justify list-disc list-outside">
        <li>If you want the files in the Emscripten file system to have the same name as on the server, use <code>files</code></li>
        <li>If you want the files in the Emscripten file system to have a <span class="italic">different</span> name than on the server, or if the URL has no file name (e.g. an API endpoint), use <code>to_file</code></li>
    </ul>
    <li>If <code>from</code> is specified, it will be used as the prefix for URL's to down files from (can be absolute or relative). Leave unspecified to reference the same relative URL path as the current document.
    <li>If <code>to_folder</code> is specified, files will be placed in that folder in the Emscripten file system; otherwise, they'll be placed in the same folder Python scripts are executed from</li>
    </li>

</ul>
<p class="post-p">The pseudo-code for what PyScript will fetch is something like this:</p>
<div class="px-8 overflow-x-scroll bg-codeblock">
<pre>
<span class="font-semibold text-red-700">if</span> both <span class="font-semibold text-blue-500">files</span> and <span class="font-semibold text-blue-500">to_file</span> are specified: Error

<span class="font-semibold text-red-700">if</span> <span class="font-semibold text-blue-500">from</span> is not specified, <span class="font-semibold text-blue-500">from</span> = ""<span class="text-green-700"> #defaults to relative URLs</span>
<span class="font-semibold text-red-700">if</span> <span class="font-semibold text-blue-500">to_folder</span> is not specified, <span class="font-semibold text-blue-500">to_folder</span> = "." <span class="text-green-700">#defaults to the working current directory, where Python Scripts are run</span>

<span class="font-semibold text-red-700">if</span> <span class="font-semibold text-blue-500">files</span> is specified:
    for each <span class="font-semibold text-blue-500">file</span> in <span class="font-semibold text-blue-500">files</span>:
        <span class="text-green-700">#These concatenations are done in a smart way to try to avoid dangling/missing "/"s</span>
        <span class="font-semibold text-blue-500">source_URL</span> = <span class="font-semibold text-blue-500">from</span> + <span class="font-semibold text-blue-500">file</span>
        <span class="font-semibold text-blue-500">destination</span> = <span class="font-semibold text-blue-500">to_folder</span> + <span class="font-semibold text-blue-500">file</span>
        download object from the source_url to destination in the local file system

<span class="font-semibold text-red-700">else:</span> <span class="text-green-700">#"files" not specified:</span>
    <span class="font-semibold text-red-700">if</span> to_file is specified:
        download object from url <span class="font-semibold text-blue-500">from</span> to <span class="font-semibold text-blue-500">(to_folder + to_file)</span>
    <span class="font-semibold text-red-700">else if</span> <span class="font-semibold text-blue-500">from</span> ends in a file-name: <span class="text-green-700">#i.e. the part after the last "/"</span>
        download object from url <span class="font-semibold text-blue-500">from</span> to <span class="font-semibold text-blue-500">(to_folder + ('filename' at end of from))</span>
</pre>
</div>
<p class="post-p">Let's look at some recipes for using these new attributes to fetch resources from the web and download them to the Emscripten local file system to Python can use them.</p>
<div class="p-2 border-2 border-blue-200 rounded-xl" id="fetch-container">
    <div class="overflow-y-scroll" style="height: 37rem;" id="fetch-examples">
        <p>For the examples where we're fetching our own files and modules, we'll assume our site has the following simple structure.</p>
        <pre class="p-4 bg-gray-200">
        content/
        ├─ <span class="font-bold">index.html <<< File with &lt;py-config&gt;</span>
        ├─ info.txt
        ├─ data/
        │  ├─ sensordata.csv
        ├─ packages/
        │  ├─ my_package/
        │  │  ├─ __init__.py
        │  │  ├─ helloworld/
        │  │  │  ├─ __init__.py/
        │  │  │  ├─ greetings.py/
        </pre>
        <div class="grid grid-cols-1 mt-4 xl:grid-cols-2 gap-x-3 gap-y-4">
        
        <div class="w-full">
        <p class="code-title">Single File</p>
        <div class="pr-4 bg-codeblock">
        {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['info.txt']
    # URL defaults to 'relative to this folder'
    # Destination defaults to 'adjacent to the Python files we run'
</py-config>
<py-script>
    with open('info.txt', 'r') as fp:
        display(fp.read())
</py-script>{{< /highlight >}}
<py-script class="hidden">
    import js
    import os
    from pyodide.ffi import to_js
    
    async def load_to_local(filepath, fetchpath):
        await js.pyscript.runtime.loadFromFile(filepath, fetchpath)

    asyncio.ensure_future(load_to_local('info.txt', 'info.txt'))
</py-script>
        </div>
        <div class="hidden mt-2 mb-6 live-example">
            <py-repl>
            with open('info.txt', 'r') as fp:
                text = fp.read()
            
            text
            </py-repl>
            </div>
        </div>
        <div class="w-full">
            <p class="code-title">Single File w/ Renaming</p>
            <div class="pr-4 bg-codeblock">
            {{< highlight "html" >}}
<py-config>
    [[fetch]]
    from = 'info.txt'
    to_file = 'info_loaded_from_web.txt'
</py-config>

<py-script>
    with open('info_loaded_from_web.txt', 'r') as fp:
        print(fp.read())
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.ensure_future(load_to_local('info_loaded_from_web.txt', 'info.txt'))
</py-script>
            </div>
            <div class="hidden my-2 mb-6 live-example">
                <py-repl>
                with open('info_loaded_from_web.txt', 'r') as fp:
                    text = fp.read()
                
                text
                </py-repl>
                </div>
            </div>
        
        <div class="w-full">
        <p class="code-title">To Another Local Folder</p>
        <div class="pr-4 bg-codeblock">
        {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['info.txt']
    to_folder = 'infofiles/loaded_info'
    # trailing slash would also be acceptable: 'infofiles/loaded_info/'
</py-config>

<py-script>
    with open("infofiles/loaded_info/info.txt", "r") as fp:
        print(fp.read())
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.ensure_future(load_to_local('infofiles/loaded_info/info.txt', 'info.txt'))
</py-script>
        </div>
        <div class="hidden my-2 mb-6 live-example">
            <py-repl>
            with open('infofiles/loaded_info/info.txt', 'r') as fp:
                text = fp.read()
            
            text
            </py-repl>
            </div>
        </div>
        
        <div class="w-full">
            <p class="code-title">From Another Folder to Current Working Directory</p>
            <div class="pr-4 bg-codeblock">
            {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['sensordata.csv']
    from = 'data/'
    # fetch file from URL 'data/sensordata.csv' to local file './sensordata.csv'
</py-config>

<py-script>
    import csv
    with open("./sensordata.csv", "r") as csvfile:
        datareader = csv.reader(csvfile)
        for row in datareader:
            display(row)
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.ensure_future(load_to_local('sensordata.csv', 'data/sensordata.csv'))
</py-script>
            </div>
            <div class="hidden my-2 mb-6 live-example">
                <py-repl>
                    import csv
                    with open("./sensordata.csv", "r") as csvfile:
                        datareader = csv.reader(csvfile)
                        for row in datareader:
                            display(row)
                </py-repl>
                </div>
            </div>

            <div class="w-full">
                <p class="code-title">From a Folder, to A Folder</p>
                <div class="pr-4 bg-codeblock">
        {{< highlight "html" >}}
<py-config>
    [[fetch]]
    # With no 'files' or 'to_file' specified, use the "file" at the end of "from"
    # This ends up at './local_data/sensordata.csv'
    from = './data/sensordata.csv'
    to_folder = './local_data'
</py-config>

<py-script>
import csv
with open("./local_data/sensordata.csv", "r") as csvfile:
    datareader = csv.reader(csvfile)
    for row in datareader:
        display(row)
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.ensure_future(load_to_local('./local_data/sensordata.csv', 'data/sensordata.csv'))
</py-script>
                </div>
                <div class="hidden my-2 mb-6 live-example">
                    <py-repl>
                        import csv
                        with open("./local_data/sensordata.csv", "r") as csvfile:
                            datareader = csv.reader(csvfile)
                            for row in datareader:
                                display(row)
                    </py-repl>
                    </div>
                </div>
        
            <div class="w-full">
                <p class="code-title">Multiple Files, Preserving Folder Structure</p>
                <div class="pr-4 bg-codeblock">
        {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['__init__.py', 'helloworld/greetings.py', 'helloworld/__init__.py']
    from = '../packages/my_package/'
    to_folder = './my_package'
</py-config>

<py-script>
from my_package.helloworld.greetings import say_hi
print(say_hi())
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.gather(*[
        load_to_local('./my_package/__init__.py', "packages/my_package/__init__.py"),
        load_to_local('./my_package/helloworld/__init__.py', 'packages/my_package/helloworld/__init__.py'),
        load_to_local('./my_package/helloworld/greetings.py', 'packages/my_package/helloworld/greetings.py')
    ])
</py-script>
                </div>
                <div class="hidden my-2 mb-6 live-example">
                    <py-repl>
                        from my_package.helloworld.greetings import say_hi
                        display(say_hi())
                    </py-repl>
                    </div>
                </div>

                <div class="w-full">
                    <p class="code-title">Multiple Fetch Configs</p>
                    <div class="pr-4 bg-codeblock">
            {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['info.txt']
    
    [[fetch]]
    from = 'data/'
    files = ['sensordata.csv']
</py-config>

<py-script>
with open('info.txt', 'rb') as fp:
    info_length = len(fp.read())

with open('sensordata.csv', 'rb') as fp:
    data_length = len(fp.read())

display(f"info.txt is {info_length} bytes and data.csv is {data_length} bytes")
</py-script>{{< /highlight >}}
    <py-script class="hidden">
        asyncio.ensure_future(load_to_local('./info.txt', './info.txt'))
        asyncio.ensure_future(load_to_local('./sensordata.csv', './data/sensordata.csv'))
    </py-script>
                    </div>
                    <div class="hidden my-2 mb-6 live-example">
                        <py-repl>
                            with open('info.txt', 'rb') as fp:
                                info_length = len(fp.read())
                            
                            with open('sensordata.csv', 'rb') as fp:
                                data_length = len(fp.read())

                            display(f"info.txt is {info_length} bytes and data.csv is {data_length} bytes")
                        </py-repl>
                        </div>
                    </div>
        
            <div class="w-full">
                <p class="code-title">From an API Endpoint</p>
                <div class="pr-4 bg-codeblock">
        {{< highlight "html" >}}
<py-config>
    [[fetch]]
    from = 'https://catfact.ninja/fact'
    to_file = './cat_fact.json'
</py-config>

<py-script>
import json
with open("cat_fact.json", "r") as fp:
    data = json.load(fp)
display(data['fact'])
</py-script>{{< /highlight >}}
<py-script class="hidden">
    asyncio.ensure_future(load_to_local('./cat_fact.json', 'https://catfact.ninja/fact'))
</py-script>
                </div>
                <div class="hidden my-2 mb-6 live-example">
                    <py-repl>
                        import json
                        with open("cat_fact.json", "r") as fp:
                            data = json.load(fp)
                        display(data['fact'])
                    </py-repl>
                    </div>
                </div>
        
        </div>
    </div>
    <div id="expand-fetch-examples" class="flex justify-center my-1">
        <p class="p-1 m-1 text-lg text-center text-gray-500 border-2 border-gray-200 rounded-lg" id="show-fetch-examples" onclick="expandFetchExamples()" style="cursor: pointer">--- Expand Examples ---</p>
    </div>
</div>
<div class="load-pyscript"></div>
<script>
    function expandFetchExamples() {
        //expand examples
        let examples_container = document.getElementById("fetch-examples")
        examples_container.style.removeProperty('height')
        examples_container.classList.remove('overflow-y-scroll')

        //remove border
        document.getElementById('fetch-container').classList.remove('border-2')

        //Hide button
        document.getElementById("expand-fetch-examples").classList.add('hidden')
    }
</script>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="PyScript">PyScript</h2>
<h4 class="post-h4">Reshaping the Python API</h4>
<p class="post-p">(Almost) all of the global variables which PyScript previously made available by default have been moved into the <code>pyscript</code> module, and should now be imported to be used. The remaining global objects are: the <code class="font-semibold">js</code> module, the <code class="font-semibold">pyscript</code> module, the <code class="font-semibold">Element</code> class (<code>pyscript.Element</code>), the <code class="font-semibold">display()</code> function (<code>pyscript.display()</code>), and the <code class="font-semibold">HTML</code> class (<code>pyscript.HTML</code>).</p>
<p class="post-p">The following global objects in PyScript 2022.09.1 should no longer be accessed as global objects, but can be imported as normal</p>
<ul class="py-2 pl-8 text-justify list-disc list-outside">
    <li>stdlib modules: <code>asyncio</code>, <code>base64</code>, <code>io</code>, <code>sys</code>, <code>time</code>, <code>datetime</code>, <code>pyodide</code>, <code>micropip</code>. Also <code>textwrap.dedent</code></li>
    <li>PyScript Objects: <code>PyScript</code> (the class), <code>PyItemTemplate</code>, <code>PyListTemplate</code>, <code>PyWidgetTheme</code>, <code>add_classes</code>, <code>create</code>, <code>loop</code></li>
    <li>Private PyScript Names (<span class="italic">members of the pyscript module, were global, but should be treated as private</span>): <code>eval_formatter</code>, <code>format_mime</code>, <code>identity</code>, <code>render_image</code>, <code>MIME_RENDERERS</code>, <code>MIME_METHODS</code></li>
    <li>From js module: <code>document</code>, <code>console</code></li>
</ul>
<p class="post-p">For example, check out the difference between the following two pieces of code from the previous and current versions:</p>
<div class="grid grid-cols-1 my-4 lg:grid-cols-2 gap-y-4 lg:gap-x-4">
    <div>
        <p class="code-title">2022.09.1 Example</p>
{{< highlight "python3" >}}
<py-script>
    console.log(sys.modules)
    async def my_coro():
        await asyncio.sleep(1)
    loop.ensure_future(my_coro())

    def foo():
        print(dedent("     FOO!"))

    document.getElementById("mydiv").addEventListner("click", pyodide.create_proxy(foo))
</py-script>
{{< /highlight >}}
    </div>
    <div>
        <p class="code-title">2022.12.1 Equivalent</p>
{{< highlight "python3" "hl_lines=1-7">}}
<py-script>
    import asyncio
    import pyodide
    import sys

    from pyscript import loop
    from js import console, document

    console.log(sys.modules)
    async def my_coro():
        await asyncio.sleep(1)
    loop.ensure_future(my_coro())

    def foo():
        print(dedent("     FOO!"))

    document.getElementById("mydiv").addEventListner("click", pyodide.create_proxy(foo))
</py-script>
{{< /highlight >}}
    </div>
</div>
<p class="post-p">Users who want to make use of PyScript-specific functions in their own modules can now use <code>import pyscript</code> to access the objects in <a href="https://github.com/pyscript/pyscript/blob/main/pyscriptjs/src/python/pyscript.py">the pyscript module</a>.</p>
<p class="post-p">Not to leave users in a lunch with this large API change, all of the global objects where were previosusly prevent are <span class="italic">still accessible but deprecated</span>. Accessing them directly will pop up a handy error message like:</p>
<div class="alert-banner py-warning md:mx-4">Direct usage of <code class="nocode">console</code> is deprecated. Please use <code class="nocode">js.console</code> instead.<button id="alert-close-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" width="12px"><path d="M.293.293a1 1 0 011.414 0L8 6.586 14.293.293a1 1 0 111.414 1.414L9.414 8l6.293 6.293a1 1 0 01-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 01-1.414-1.414L6.586 8 .293 1.707a1 1 0 010-1.414z"></path></svg></button></div>
<p class="post-p">For context: prior to this version, all of the Python side of PyScript - the hooks which made stdout work, <code>Element.write()</code>, the PyScript class - was included into user code in a clever but inintuitive way. The methodology equivalent to loading the contents <a href="https://github.com/pyscript/pyscript/blob/main/pyscriptjs/src/python/pyscript.py">pyscript.py</a> as a string and calling <code>exec(contents)</code> on that string. This worked, but made it difficult for users to use these PyScript functions in their own modules, and limited how the module could be used for type-checking. Things are better now!</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Plugins!</h4>
<p class="post-p">As was so nicely phrased on the <a href="#community">October Community Call</a>, PyScript is aiming to be a "platform", not a "framework". That is, it should provide lots of hooks, triggers, and signals to allow users to <span class="italic">expand</span> the usability of PyScript, rather than forcing users to do things "The PyScript Way."</p>
<p class="post-p">The idea of using "plugins" to do this has been floating around for awhile now - some straightforward way of allowing users to cause their own code to be run at certain points in the PyScript lifecycle. But within that "simple" idea are many questions - should this be JavaScript or Python Code (or both/either)? Should the triggering mechanism be callback-based, event-based, or some other way? How much of the core functionality of PyScript should happen every time, or should we simply define a lifecycle and move <span class="italic">everything</span> to a Plugin?</p>
<p class="post-p">PyScript 2022.12.1 gets the ball rolling on this by <span class="font-semibold">allowing users to author plugins in Python and use them to extend PyScript</span>. (<a href="https://github.com/pyscript/pyscript/pull/961">#961</a>) This behavior has only be recently merged, and deserves it's own full writeup anyway, but here's a brief description of the process of authoring a Python plugin:</p>
<ul class="post-ul">
    <li>In a separate <code>.py</code> file (module), write a class that extends the <code>pyscript.Plugin</code> class.</li>
    <ul class="py-1 pl-8 text-justify list-disc list-outside;">
        <li>This class can implement any of the valid Python <a href="https://github.com/pyscript/pyscript/blob/8b7fb89c6862f9e7d3388248a4b5f5d411da06db/pyscriptjs/src/plugin.ts#L70-L96">named lifecycle callbacks</a>, which will be called at determined points in the PyScript loading lifecycle.</li>
        <li class="italic">We could use some more documentation on these methods, to be honest, but the development on this is flying fast and furious. Keep your eyes peeled!</li>
    </ul>
    <li>In this module, create an instance of this class named plugin, and pass the constructor the name of the plugin. I.e. <code>plugin = Plugin("myNewPlugin")</code></li>
    <li>In <code>&lt;py-config&gt;</code>, add the URL (relative or absolute) of this file to the "plugins" attribute. I.e. <code>plugins = ['../my_folder/plugins/myNewPlugin.py"]</code></li>
    <li>When PyScript reaches any of the defined lifecycle points, the corresponding methods of the Plugin will be called.</li>
</ul>
<p class="post-p">Additionally, there's provision on the Python side for creating custom HTML elements via a Python plugin. See <a href="https://github.com/pyscript/pyscript/blob/8b7fb89c6862f9e7d3388248a4b5f5d411da06db/pyscriptjs/src/plugins/python/py_markdown.py#L23-L31">the Markdown Plugin example</a> for a demo of how this works.</p>
<p class="post-p">Finally, PyScript is using a plugin system internally to implement some of its core behaviors. The <code>&lt;py-terminal&gt;</code> page element (<a href="https://github.com/pyscript/pyscript/pull/917">#917</a>), the splashscreen which appears when PyScript is loading, and the <code>importmap</code> functionality which allows loading importmap ES modules into Python (<a href="https://github.com/pyscript/pyscript/pull/938">#938</a>), are all implemented in TypeScript as plugins. Currently, there's no ability for the user to write their own JavaScript plugins, but that's a potential (and powerful) behavior for the future.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">No More Implicit Coroutines</h4>
<p class="post-p">Prior to version 2022.12.1, PyScript allowed the use of Top-Level-Await statements. That is, <code>await</code>, <code>async for</code>, and <code>async with</code> outside of coroutines (<code>async def</code> functions). When it encountered such a block of Python, it automatically wrapped the block up into a coroutine and scheduled it to run in the event loop.</p>
<p class="post-p"><span class="font-semibold">As of PyScript 2022.12.1, this is no longer allowed.</span> Users should write their async functions as coroutines using <code>async def</code>, and schedule them using <a href="https://jeff.glass/post/pyscript-asyncio#webloop">the allowed webloop methods</a> like <code>asyncio.create_task()</code> or <code>asyncio.ensure_future()</code></p>
<p class="post-p">The doesn't actually remove anything that was previously possible with PyScript - it only requires that users be more explicit about scheduling their coroutines. Compare the two following, equivalent examples from PyScript 2022.09.1 and 2022.12.1:</p>
<div class="grid grid-cols-1 my-4 lg:grid-cols-2 gap-y-4 lg:gap-x-4">
    <div>
        <p class="code-title">2022.09.1 Example</p>
{{< highlight "python3" >}}
<py-script>
    import asyncio
    import js

    for i in range(5):
        js.console.log(i)
        await asyncio.sleep(1)
</py-script>
{{< /highlight >}}
    </div>
    <div>
        <p class="code-title">2022.12.1 Equivalent</p>
{{< highlight "python3" >}}
<py-script>
    import asyncio
    import js

    async def my_coro:
        for i in range(5):
            js.console.log(i)
            await asyncio.sleep(1)

    asyncio.ensure_future(my_coro())
</py-script>
{{< /highlight >}}
    </div>
</div>
<p class="post-p">For more techniques and background, you can check out my <a href="/post/pyscript-asyncio/">long writeup on Asyncio in PyScript</a> from last month. Antonio and I also got <a href="https://github.com/pyscript/pyscript/issues/879#issuecomment-1289415317">deep in the weeds of how Pyodide's <code class="nocode">runPythonAsync()</code> works</a> (which we previously used to implicitly schedule coroutines), and some of its limitations, if you want to dive even deep.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">PyScript JS module</h4>
<h5 class="pt-3 text-lg">Pyodide Runtime Access</h5>
<p class="post-p"><code>pyscript.js</code> now exposes the instance of Pyodide it creates <a href="https://docs.pyscript.net/latest/reference/pyscript-module.html">as a JavaScript object</a>. Users wishing to run code directly in Pyodide, or to use another JavaScript module that interacts directly with Pyodide, can use this exported reference to do so. (<a href="https://github.com/pyscript/pyscript/pull/868">#868</a>)</p>
<p class="post-p warning-banner">The current method of access makes no guarantees about the state of the runtime when accessed - users will need to implement their own method of checking whether the runtime is loaded/initialized before accessing it. This is <a href="https://github.com/pyscript/pyscript/issues/942">likely to change in the future</a>.</p>
<p class="post-p">The Pyodide runtime is accessible as <code class="code">pyscript.runtime.interpreter</code>, like so:</p>
<div class="mx-4 my-2">
{{< highlight "html" >}}
<script defer src="https://pyscript.net/releases/2022.12.1/pyscript.js"></script>
<button onclick="logFromPython()">Click Me to Log</button>
<script>
    function logFromPython() {
        pyscript.runtime.interpreter.runPython(`
            from js import console
            console.log(f"Hello from Python! {1 + 2 = }")
        `)
    }
</script>{{< /highlight >}}
    </div>
<p class="post-p">Note that the runtime will not be available until it has been loaded by PyScript and initialized. In the example above, we use a button to defer executing the desired code until sometime after PyScript has initialized; in the next example, we'll use an <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">Event</a>.</p>
<p class="post-p">The <code class="code">pyscript.runtime.globals</code> attribute holds a reference to Python <code>globals()</code> dictionary, making it easy to reference Python objects from JavaScript. By the wonder that is Pyodide, the objects are proxied back and forth pretty much seamlessly, but especially when logging to the console, using the <a href="https://pyodide.org/en/stable/usage/api/js-api.html#PyProxy.toJs">toJs()</a> function makes the conversion explicit:</p>
<div class="mx-4 my-2">
{{< highlight "html" >}}
<script defer src="https://pyscript.net/releases/2022.12.1/pyscript.js"></script>

<py-script>
    from js import document, Event

    techs = ["PyScript", "Pyodide", "WASM"]
    number_of_techs = len(techs)

    # Use an Event to trigger JS after PyScript has initialized/run:
    pydone = Event.new("py-done")
    document.dispatchEvent(pydone)
</py-script>

<script>
    document.addEventListener("py-done", () => {
        console.log(pyscript.runtime.globals.get("number_of_techs"))
        console.log(pyscript.runtime.globals.get("techs").toJs())
    })
</script>{{< /highlight >}}
    <div class="m-2">
        <p class="italic">Dev Console Result:</p>
        <img class="border-2 border-gray-400" src="consoledemo1.PNG" alt="A pair of entries from the developer console reading '3' and 'PyScript', 'Pyodide', 'WASM'">
    </div>
</div>
<h5 class="pt-3 text-lg">PyScript Version Numbers (JavaScript)</h5>
<p class="post-p">You can also access the current version of PyScript via the pyscript js module at <code>pyscript.version</code>. This will appear as a "dotted string" like <code class="code">2022.12.1.dev</code> But version numbers are even more powerful on the Python side.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">PyScript Version Numbers (Python)</h4>
<p class="post-p">Up to this point, the current PyScript version is something a user would have to infer from what URL they sourced <code class="code">pyscript.js</code> from. As of version 2022.12.1, though, you can access that information directly in Python via a couple of new attributes.</p>
<p class="post-p"><a href="https://docs.pyscript.net/latest/reference/API/version_info.html" class="font-semibold">PyScript.version_info</a> is a <code>nametuple</code> representing the current version in a code-savvy way - it's intended for use when comparing version numbers, i.e. to establish feature compatibility. For example:</p>
<p class="code-title">Using version_info</p>
{{< highlight "python3" >}}
<py-script>
    import js
    if PyScript.version_info >= (2022,11,1,""):
          js.console.log("You should be using [[fetch]] configs")
    else:
          js.console.log("You should be using &lt;py-config&gt; paths:")
</py-script>
{{< /highlight >}}
<div class="hidden my-4 live-example">
    <py-repl>
        import js
        if PyScript.version_info and PyScript.version_info >= (2022,11,1,""):
            display("This text was output using display()")
        else:
            print("This text was output using print()")
    </py-repl>
</div>
<p class="post-p">On the other hand, <a href="https://docs.pyscript.net/latest/reference/API/__version__.html" class="font-semibold">PyScript.__version__</a> is a human-readable version of the current version, like "2022.12.1.final"</p>
<p class="code-title">Using __version__</p>
{{< highlight "python3" >}}
display(f"The current version of PyScript running right now is {PyScript.__version__}")
{{< /highlight >}}
<div class="hidden my-4 live-example">
    <py-repl>
        display(f"{PyScript.version_info= }")
        display(f"{PyScript.__version__= }")
    </py-repl>
</div>
<div class="load-pyscript"></div>
<h4 class="post-h4 md:border-b-2 md:border-gray-200"><code>&lt;py-button&gt;</code>, <code>&lt;py-inputbox&gt;</code>, <code>&lt;py-box&gt;</code>, and <code>&lt;py-title&gt;</code> are Deprecated</h4>
<p class="post-p">All four of these custom HTML elements, which have been present in PyScript since its alpha release, have been deprecated. In the continuing vein of trying to make PyScript into a strong, versatile, and minimal core, it was decided that these elements weren't really key - they're easy enough to implement <span class="italic">with</span> PyScript, enough so that they don't need to be included elements by default. <code>&lt;py-button&gt;</code> and <code>&lt;py-inputbox&gt;</code> are simple enough to replicate with existing HTML elements and event listeners, while <code>&lt;py-box&gt;</code> and <code>&lt;py-title&gt;</code> were pre-formatted <code>&lt;div&gt;</code>s.</p>
<p class="post-p">Those components haven't been fully removed from PyScript yet, just deprecated, and nicely, the deprecation warning banner that appears suggests altenate elements with new CSS classes that maintain the old elements' styling. The suggested solutions are:</p>
<div class="flex justify-center my-2">
    <table class="w-full text-center md:w-2/3">
        <tr>
            <th>Deprecated Tag</th>
            <th>Replacement Solution</th>
        </tr>
        <tr>
            <td><code>&lt;py-button&gt;</code></td>
            <td><code>&lt;button py-click=&quot;function()&quot; class=&quot;py-button&quot;&gt;</code></td>
        </tr>
        <tr>
            <td><code>&lt;py-inputbox&gt;</code></td>
            <td><code>&lt;input class=&quot;py-input&quot;&gt;</code></td>
        </tr>
        <tr>
            <td><code>&lt;py-box&gt;</code></td>
            <td><code>&lt;div class=&quot;py-box&quot;&gt;</code></td>
        </tr>
        <tr>
            <td><code>&lt;py-title&gt;</code></td>
            <td><code>&lt;h1&gt;</code></td>
        </tr>
    </table>
</div>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Better Warnings and Errors</h4>
<p class="post-p">Fabio Rosado (yes, there's <a href="#maintainers">two Fabios</a> on the PyScript team now!) put together a series of great PRs that clean up the presentation of warnings and errors caused during PyScript's lifecycle.</p>
<p class="post-p">If you write invalid TOML for <code>&lt;py-config&gt;</code>, say, or use a deprecated function or feature. (<a href="https://github.com/pyscript/pyscript/pull/909">#909</a>). The banners can contain either plain text or HTML, which will allow us a lot of flexibility going forward in how we use them. (<a href="https://github.com/pyscript/pyscript/pull/947">#947</a>) </p>
<div class="alert-banner py-error">(PY1000): The config supplied: x=
    is an invalid TOML and cannot be parsed: SyntaxError: Expected "+", "-", "[", "false", "true", "{", DoubleQuote, FullDate (YYYY-mm-dd), SingleQuote, ThreeDoubleQuotes, ThreeSingleQuotes, Whitespace, [0-9], or [1-9] but "\n" found.</div>
    <div class="alert-banner py-warning">Multiple &lt;py-config&gt; tags detected. Only the first is going to be parsed, all the others will be ignored<button id="alert-close-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" width="12px"><path d="M.293.293a1 1 0 011.414 0L8 6.586 14.293.293a1 1 0 111.414 1.414L9.414 8l6.293 6.293a1 1 0 01-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 01-1.414-1.414L6.586 8 .293 1.707a1 1 0 010-1.414z"></path></svg></button></div>
    <pre class="mx-8 py-error">Traceback (most recent call last):<br>  File "/lib/python3.10/site-packages/_pyodide/_base.py", line 435, in eval_code<br>    .run(globals, locals)<br>  File "/lib/python3.10/site-packages/_pyodide/_base.py", line 304, in run<br>    coroutine = eval(self.code, globals, locals)<br>  File "&lt;exec&gt;", line 1, in &lt;module&gt;<br>ZeroDivisionError: division by zero<br></pre>
<p class="post-p">And you might notice, the PyScript errors errors now include error codes! As the PyScript codebase grows, and community involvement increases, having short-and-simple error codes helps users find solutions to exactly the issue they're having. It encourages users to report "When I do X, I get a PY2401 error" instead of just "I got an error." This improves searchability the <a href="https://docs.pyscript.net/unstable/reference/exceptions.html">error code docs</a>, in the forums, and on discord, and makes it simpler to guide users to solutions to specific issues they're encountering in the PyScript lifecycle. (<a href="https://github.com/pyscript/pyscript/pull/959">#959</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Streamlined py-config</h4>
<p class="post-p">The py-config system has been overhauled to simply its use internally - including simplifying how the default configuration options are merged with user-supplied options (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>), dealing with multiple <code>&lt;py-config&gt;</code>s on a page (<a href="https://github.com/pyscript/pyscript/pull/826">#826</a>), and finally killing <code>&lt;py-env&gt;</code> altogether (<a href="https://github.com/pyscript/pyscript/pull/775">#775</a>).</p>
<p class="post-p">The TOML parser handling has also been improved, in that it no longer hangs forever if given misshapen TOML. (<a href="https://github.com/pyscript/pyscript/pull/815">#815</a>)</p>
<p class="post-p">An important clarification has also been added to the docs - because of <a href="https://toml.io/en/">the way the TOML format works</a>, if you're using TOML for your py-config, <code>[[runtimes]]</code> must be the last element. If the <code>[[runtimes]]</code> table precedes the other individual elements (like `paths` or `packages`), those elements end up <span class="italic">inside</span> <code>[[runtimes]]</code>, which will cause them to be missed. (<a href="https://github.com/pyscript/pyscript/pull/861">#861</a>)</p>
<p class="post-p">This in addition to the <a href="#paths">changes to <code>[[fetch]]</code> noted above</a>.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Undefined elements are no longer hidden</h4>
<p class="post-p">Previous, any unknown HTML elements were hidden by <code>pyscript.css</code> in an attempt to suppress onscreen visibility of things like <code>&lt;py-config&gt;</code>. This had the unintended consequence of hiding elements with typos - for example, a user-typed <code>&lt;py-scrip&gt;</code> element would be "unknown" and also hidden. Now, PyScript explicitly only hides the page-elements that need hiding. (<a href="https://github.com/pyscript/pyscript/pull/837">#837</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Directory Listings for Releases</h4>
<p class="post-p">PyScript releases now come with a directory-listing of files and a brief example. See, for example, <a href="https://pyscript.net/unstable/">https://pyscript.net/unstable</a>. (<a href="https://github.com/pyscript/pyscript/pull/839">#839</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">CodeMirror 6</h4>
<p class="post-p">Just like <a href="https://blog.jupyter.org/accelerating-jupyterlab-68942bb8d602#2404">JupyterLab 6</a>, PyScript now uses the latest version of CodeMirror to power the in-browser <code>&lt;py-repl&gt;</code> component. This comes with a (far more stable) API and <a href="https://codemirror.net/docs/migration/">lots of other improvements.</a> (<a href="https://github.com/pyscript/pyscript/pull/814">#814</a>)</p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="infrastructure">Infrastructure</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Documentation</h4>
<p class="post-p">Especially in the past couple weeks, there's been a flood of new additions to the documentation! As the changes and improvements for this release settled into their final form, the team focused on making sure as many of the changes were documented as possible. A small sample of the new pages:</p><ul class="post-ul">
    <li><a href="https://docs.pyscript.net/latest/reference/index.html">API reference</a> for <code>Element</code>, <code>display()</code>, <code>__version__</code>, and <code>version_info</code></li>
    <li><a href="https://docs.pyscript.net/latest/guides/asyncio.html">Updating Implicit Async to Explicit</a>, </li>
    <li>The <a href="https://docs.pyscript.net/latest/reference/modules/pyscript.html">pyscript module</a> in javascript</li>
    <li><a href="https://docs.pyscript.net/latest/reference/exceptions.html">Exceptions and Error Codes</a></li>
    <li><a href="https://docs.pyscript.net/unstable/tutorials/py-config-fetch.html">Using [[fetch]] from py-config</a></li>
    <li><a href="https://docs.pyscript.net/unstable/tutorials/writing-to-page.html">Writing content to the Page</a></li>
</ul>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Dev Docs</h4>
<p class="post-p"><a href="https://docs.pyscript.net/latest/index.html">The PyScript Documentation</a> now has a <a href="https://docs.pyscript.net/latest/development/">Development Section</a>, as a central place for notes about how the development and release process for PyScript works. In particular, there are documents on the <a href="https://docs.pyscript.net/latest/development/deprecation-cycle">deprecation cycle</a>, <a href="https://docs.pyscript.net/latest/development/setting-up-environment">getting your development environment set up</a>, and <a href="https://docs.pyscript.net/latest/development/developing">making and submitting a pull request</a>.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Refactoring PyScript</h4>
<p class="post-p">Antonio, Mariana, Madhur, and many more besides have embarked on several of massive refactoring endevours of the TypeScript side of PyScript, to streamline and rationalize the process of how PyScript loads itself and Pyodide and how it then executes Python scripts. Hopefully the changes this imparts to the end-users of PyScript are minimal, but speaking from a maintenance and codebase standpoint, the amount that's been done to make sense of both of these processes makes it a significantly easier to reason about what-happens-when. (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>, <a href="https://github.com/pyscript/pyscript/pull/850">#850</a>, <a href="https://github.com/pyscript/pyscript/pull/881">#881</a>, <a href="https://github.com/pyscript/pyscript/pull/884">#884</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Testing</h4>
<p class="post-p">The pytest-driven test system used to re-download the Pyodide runtime and other resources for each test, significantly slowing it down. The test system now has the ability to cache resources between tests, and retry tests on network failures. (<a href="https://github.com/pyscript/pyscript/pull/829">829</a>)</p>
<p class="post-p">We also now have a way for the test system to watch for and confirm that specific errors are being thrown, allowing for the writing of <span class="italic">negative</span> integration tests (that should throw specific errors in PyScript). (<a href="https://github.com/pyscript/pyscript/pull/874">#874</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Goodbye Svelte</h4>
<p class="post-p">The original version of the <a href="https://pyscript.net/examples/">PyScript Demo Site</a> and other parts of the build infrastructure and styling were built around <a href="https://svelte.dev/">Svelte</a>. Thanks to several PRs and lots of refactoring, Svelte is now entirely gone (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>, <a href="https://github.com/pyscript/pyscript/pull/830">#830</a>, <a href="https://github.com/pyscript/pyscript/pull/886">#886</a>) </p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="pyodide">Pyodide</h2>
<p class="post-p">Pyodide did have another minor release recently, <span class="italic">0.21.3</span>. And while it wasn't anywhere near as big a change as the 0.20 to 0.21 release, a few critical fixes did make their way in. See <a href="https://pyodide.org/en/stable/project/changelog.html#version-0-21-3">the Pyodide Changelog</a> for details.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Relative URLs for Index URLs</h4>
<p class="post-p">In Version 0.21.2, it was briefly impossible to use a relative URL as a the indexURL for the Pyodide package (where it looks to load the Python side of its runtime and other key support files). That's now fixed. (<a href="https://github.com/pyodide/pyodide/pull/3077">Pyodide # 3077</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Source Maps Restored</h4>
<p class="post-p">A couple PyScript users reported concerns about seeing a "Source Map Unavailable" error in their dev console, thinking they had done something wrong. Turns out that was due to a minor regression in Pyodide causing that source map file not to be distributed. That's since been rectified. (<a href="https://github.com/pyodide/pyodide/pull/3088">Pyodide #3088</a>)</p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="Community">Community</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Discord</h4>
<p class="post-p">The <a href="https://discord.gg/CQU2Qyeb">PyScript Discord</a> is now the official hub for realtime communication around PyScript - both internally for the maintainers and the for the community to gather, ask questions, and get help.</p>
<p class="post-p">This is a really amazing shift by the staff PyScript team over at Anaconda - to bring the conversations about PyScript out to a place where the community can see them and be a part of them. Want to see the maintainers getting deep in the weeds about the Plugins API, how <code>[[fetch]]</code> should work, or what qualifies as "a Python"? It's all out in the open on Discord.</p>
<p class="post-p">Similarly, there's more an more Pyscripters hanging out in the Discord <span class="font-semibold">#chat</span> and <span class="font-semibold">#pyscript-help</span> channels, to help folks get unstuck or identify issues. And the <span class="font-semibold">#i-made-this</span> and <span class="font-semibold">#i-found-this</span> are great places to share neat things you've made or discovered with PyScript.</p>
<p class="post-p">Come join us!</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200" id="community">October Community Call</h4>
<p class="post-p">The PyScript core team hosted its <a href="https://github.com/pyscript/pyscript/issues/836">first Community Call</a> on October 18th! (<a href="https://github.com/pyscript/pyscript/issues/836">#836</a>) About a dozen people attended, mostly from the PyScript core team and related contributors. We unfortunately forgot to hit 'record' on the call, but I did jot down a few notes. <span class="italic">(None of this should be taken as gospel or comprehesive; It's just what I, one dude, happened to scribble down.)</span></p>
<ul class="post-ul">
    <li>The team is going to be shooting for about 1 release per month - maybe more, maybe less, but that's a decent goal.</li>
    <li>The lifecycle refactoring is well underway, with Antonio C leading the charge on removing global variables, streamining the loading, etc.</li>
    <li>Similarly, the refactoring away from print() to display() being lead by Mariana was just merged yesterday!</li>
    <li>Plugins!
        <ul class="py-1 pl-8 text-justify list-disc list-outside ul-circle">
            <li>The team is excited about streamlining and <span class="italic">minimizing</span> the core details of what PyScript does. There's a feeling that when PyScript initializes, it should do a 'bare minimum' to get itself running, and delegate lots of core behaviors to plugins, to allow for customizability, extensibility, and futureproofing. An emphasis on PyScript being a 'platform' not a 'framework'</li>
            <li>It is very early days for this idea, but there's lots of excitement around it.</li>
        </ul>
    </li>
    <li>Web Workers are an awesome way to delegrate work, but there's going to be a significant amount of work integrating the message passing/isolation process with PyScript.</li>
    <li>Cleaning up the PyScript API would be nice, in the sense of the Python objects in <a href="https://github.com/pyscript/pyscript/blob/main/pyscriptjs/src/python/pyscript.py#L1-L394">PyScript.py</a> are currently available by default when executing PyScript. Generally, there's agreement around this wanting to all be contained in a module, though there's some questions around what of that would want be <code>import</code>ed by default into a PyScript environment.</li>
        <ul class="py-1 pl-8 text-justify list-disc list-outside ul-circle">
            <li>This would allow IDE's and intellisense to have a chance at working with PyScript.</li>
        </ul>
</ul></p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">November Community Call</h4>
<p class="post-p">The second-even community call was held November 16th, also on Zoom, and also with a ton of great discussion and conversation. I personally missed the first three-quarters of it (<span class="italic">I had a 45-foot tall Christmas tree to get lit</span>), but Nicholas very kindly took notes in addition to his hosting duties, which are reproduced below:</p>
<ul class="post-ul">
    <li>We need to ensure we have an agenda. We've agreed to think about this and suggest proposals here so we have a process to try by our next community call.</li>
    <li>Given Discord does video calls, and/or there's Twitch and other services for streaming meetings that are more in or of the platform we're using for our community, we should perhaps look at those as an alternative to Zoom.</li>
    <li>Perhaps we should record our meetings..?</li>
    <li>PyCon US next year, what's going on. We should coordinate, compliment and amplify each others' work / efforts in this area. Can tell all here please..?</li>
    <li>Antonio - can you let Jeff know what's coming in the plugin work? (This might be helpful context: https://github.com/pyscript/pyscript/pull/938)</li>
    <li>We had some really great in-depth technical discussion about web-assembly, DOM and JS access, GCs, blocking calls, dynamic linking and all sorts of other good stuff... oh my..!</li>
    <li>A very positive vibe. Let's keep this up. 🎉</li>
</ul>
<p class="post-p">And indeed, the vibes were incredibly positive. Every maintainer on the PyScript project has gotten their hands on (in my opinion) some very neat part of PyScript in the past two months. I'm very much looking forward to what this enthusiastic, generous, and considerate team does next.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Awesome PyScript</h4>
<p class="post-p"><a href="#maintainers">Maintainer Paul Everitt</a> has been hard at work assembling <a href="https://github.com/pyscript/pyscript-collective/blob/main/awesome-pyscript.md">Awesome PyScript</a>, a curated list of awesome things relative to PyScript. If you want inspiration on what PyScript can do, this is the place to go - there's collections of videos, demos, conference talks, and more.</p>
<p class="post-p">Have you done something awesome with PyScript? Drop the Awesome PyScript repo a comment or a Pull Request to have it included!</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">PyScript/Research</h4>
<p class="post-p">A new GitHub repository at <a href="https://github.com/pyscript/research">PyScript/Research</a> has been started, as a home for overarching research, development, and proposals for PyScript. New and great ideas were popping up in issues in the main repo and being lost somewhat, so the new repo is a home for larger proposals that need need multiple files to explain, or that generate longer discussions than fit in a single issue.</p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="Team">The PyScript Team</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200" id="maintainers">New Maintainers</h4>
<p class="post-p"><a href="https://github.com/pauleveritt">Paul Everitt</a>, <a href="https://github.com/FabioRosado">Fabio Rosado</a> and I are now community maintainers on the PyScript project. It's been tremendously exciting and satisfying working on and with PyScript the past few months - the core team over at Annaconda has been swell all around, and I'm very grateful to be a part of the team in my own way. (<a href="https://github.com/pyscript/pyscript/pull/824">#824</a> <a href="https://github.com/pyscript/pyscript/pull/825">#825</a> <a href="https://github.com/pyscript/pyscript/issues/898">#898</a>)</p>
<h2 class="pb-1 border-b-2 border-gray-500 post-h2 anchor" id="Next">What's Next?</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Events</h4>
<p class="post-p">There's a proposal (a couple proposals) swirling around over in <a href="https://github.com/pyscript/research">PyScript/Research</a> about the syntax for events ("py-[event]" or "onclick" or otherwise). What's exciting is that there's tons of possibilities! Now the hard part will be to sort together the possibilities and potentiatials, weight up the pros and cons (run functions in Python vs. JavaScript, access to JS and/or Python objects as arguments, do we pass literal code or references to Callables, etc) and make the call.</p>
<p class="post-p">...At least for now. This is another area that might see two or three more rounds of evolution before it stabilizes. Or even potentially splits into more than one thing - there may be multiple independent systems being developed that can coexist. Time will tell.</p>
<h4 class="bg-red-200 post-h4 md:border-b-2 md:border-gray-200">PyScript's Python API</h4>
<p class="bg-red-200 post-p">There's some strong agreement among the maintainers, I would say, that something needs to be done about <a href="https://github.com/pyscript/pyscript/blob/beb3aa157419ecb53863c76674069c78cb48dfe1/pyscriptjs/src/python/pyscript.py">PyScript.py</a>, the Python side of what PyScript is. Right now, the file in its entirety is run when the Pyodide runtime starts and its... a lot. There's a lot of great functionality there - especially with the new <code>display()</code> syntax being merged - but it feels little haphazard. There's a sense that it should maybe be... a module? A package? Several modules? Something an IDE can ingest and use for autocompletion say. Or maybe there's a better way?</p>
<p class="bg-red-200 post-p">And once that Python is rationalized, there's the question of "How many of the objects defined in this file(s) should be imported by default?" All/some/none? Are some core enough to what PyScript "is" that they should always be imported? Key questions for sure, and ones which will probably break things when answered. But breaking things is good!</p>
<p class="bg-red-200 post-p">Here's to breaking more things.</p>