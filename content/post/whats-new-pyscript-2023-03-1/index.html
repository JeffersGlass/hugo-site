---
title: "What's New in Pyscript 2023.03.1"
date: 2023-03-10T19:01:29-06:00
draft: false
tags:
- pyscript
- python
- pyodide
- javascript
description: "What's New in PyScript 2023.03.1"
slug_image: py_2023_03_1_featured.png
---
<py-script class="hidden">
    import js
    loaded_event = js.Event.new('pyscript_ready')
    js.document.dispatchEvent(loaded_event)
</py-script>
<style>
    code:not(.nocode):not(.language-python):not(.language-python3):not(.language-html):not(.language-js){
        --tw-text-opacity: 1;
        color: rgba(5, 120, 85, var(--tw-text-opacity));
    }
    .py-terminal{
        min-height: 10em;
        background-color: black;
        color: white;
    }
    .py-pop-up {
    text-align: center;
    width: 600px;
    }

    .py-pop-up p {
        margin: 5px;
    }

    .py-pop-up a {
        position: absolute;
        color: white;
        text-decoration: none;
        font-size: 200%;
        top: 3.5%;
        right: 5%;
    }

    /* Pop-up second layer end */
    .alert-banner {
        position: relative;
        padding: .5rem 1.5rem .5rem .5rem;
        margin: 0.5rem 2rem;
    }

    .alert-banner p {
        margin: 0;
    }

    .py-error{
        background-color: #FFE9E8;
        border: solid;
        border-color: #f0625f;
        color: #9d041c;
    }

    .py-warning {
        background-color: rgb(255, 244, 229);
        border: solid;
        border-color: #ffa016;
        color: #794700;
    }

    .alert-banner.py-error>#alert-close-button {
        color: #9d041c;
    }

    .alert-banner.py-warning>#alert-close-button {
        color: #794700
    }

    #alert-close-button {
    position: absolute;
    right: .5rem;
    top: .5rem;
    cursor: pointer;
    background: transparent;
    border: none;
    }
    
</style>
<script>    
    //Create Load PyScript buttons:
    document.addEventListener('DOMContentLoaded', () => {
        btn_locations = document.getElementsByClassName('load-pyscript')
        Array.from(btn_locations).forEach(div => {
            div.classList.add('my-2', 'mx-8', 'border-blue-200', 'rounded-xl', 'flex', 'flex-row', 'justify-center', 'w-auto', "py-1")
            let p = document.createElement('p')
            p.classList.add('my-auto', 'mr-4', 'italic')
            p.innerText = "Want to run these examples live in your browser?"
            div.appendChild(p)
            //button
            let btn = document.createElement('button')
            btn.innerText = "Load PyScript"
            btn.classList.add('load-pyscript-button')
            btn.onclick = loadPyScript
            div.appendChild(btn)
        });
    })
    function setupLoadButtons(){

    }
    function loadPyScript() {
        //load css
        css_link = document.createElement("link")
        css_link.rel = "stylesheet"
        css_link.type = "text/css"
        css_link.href = "https://pyscript.net/releases/2023.03.1/pyscript.css"
        //css_link.href = "https://pyscript.net/unstable/pyscript.css"
        //css_link.href = "http://127.0.0.1:5501/pyscriptjs/build/pyscript.css"
        //css_link.href = "./pyscript.css"
        document.getElementsByTagName('head')[0].appendChild(css_link)

        //load cs
        script_tag = document.createElement('script')
        script_tag.src = "https://pyscript.net/releases/2023.03.1/pyscript.js"
        //script_tag.src = "https://pyscript.net/unstable/pyscript.js"
        //script_tag.src = "http://127.0.0.1:5501/pyscriptjs/build/pyscript.js"
        //script_tag.src = "./pyscript.js"
        document.body.append(script_tag) 
    }
    document.addEventListener('pyscript_ready', () => {
        static = document.getElementsByClassName('static-example')
        live = document.getElementsByClassName('live-example')
        Array.from(static).forEach(div => {
            div.classList.add('hidden')
        })
        Array.from(live).forEach(div => {
            div.classList.remove('hidden')
        })
        load_buttons = document.getElementsByClassName('load-pyscript')
        Array.from(load_buttons).forEach(elem => {
            elem.classList.add('hidden')
        })
    })
</script>
<p class="post-p">The PyScript team is absolutely steamrolling ahead in the past few months, working toward a new version of the PyScript open source library and <span class="italic">some other developments</span> that will become visible in the near future. <span id="tease">(I hate to be a tease, but this isn't my piñata to pop).</span> What follows is a writeup of the new improvements, features, and deprecations in <a href="https://github.com/pyscript/pyscript/releases/tag/2023.03.1">PyScript 2023.03.1</a>.</p>
<p class="post-p">If the <a href="#pyscript">PyScript section</a> looks a little shorter than the last release, well, the last release set a very high bar! But there are a couple other reasons why there's less user-facing changes to talk about this time. It's partly because the team wanted to do a release to pin some key features before pushing some really significant PyScript changes that are coming soon - skip down to <a href="#whatsnext">"What's Next?"</a> for those.</p>
<p class="post-p">But additionally, a ton of work has been happening under the hood, especially in the past few weeks. Better linting, testing, deployment; unvendoring some necessary packages; refining and clarifying our approach to changes and issues. The kind of things that don't fill out a blog post, but make a big difference in the long run.</p>
<p class="post-">What's <span class="italic">not</span> listed here are bugfixes, and they have been several nice ones since the last release. For that kind of granular information, see the newly-added <a href="https://github.com/pyscript/pyscript/blob/main/docs/changelog.md">changelog document</a>.</p>
<p class="post-p">As always, for help, discussion, and bleeding-edge development on PyScript, come join us on <a href="https://discord.gg/Y5MFvW5hbs">The Discord Server</a>.</p>
<div id="TOC" class="grid justify-center p-1 m-auto bg-gray-200">
    <span>Jump To: <span>
    <a href="#pyscript">PyScript</a> • 
    <a href="#plugins">Plugins</a> • 
    <a href="#pyodide">Pyodide</a> • 
    <a href="#documentation">Documentation</a> • 
    <a href="#whatsnext">What's Next?</a>
</div>
<h2 class="post-h2" id="pyscript">PyScript</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200" id="output"><code>&lt;py-script&gt; output="..."</code></h4>
<p class="post-p">The <code>output</code> attribute of the <code>&lt;py-script&gt;</code> tag has been restored. (<a href="https://github.com/pyscript/pyscript/pull/1063">#1063</a>) This allows PyScript users to route Python's output to <code>stdout</code> to a specific place in the dom, like so:</p>
<div class="m-2">
    <div>
    {{< highlight "html" "linenostart=1">}}<py-script output="some-div">{{< /highlight >}}
    {{< highlight "python3" "linenostart=2">}}
    print("Hello world!")
    print("This output should go somewhere"){{< /highlight >}}
    {{< highlight "html" "linenostart=4">}}
</py-script>
{{< /highlight >}}
    </div>
    <div class="px-2 my-2 bg-gray-200">
        <p class="mb-2 ml-2 text-sm text-gray-600">#some-div</p>
        <p class="ml-2 font-mono">Hello world!</p>
        <p class="ml-2 font-mono">This output should go somewhere</p>
    </div>
</div>
<p class="post-p">Users who are writing code <span class="italic">specifically for PyScript</span> can use the <a href="https://docs.pyscript.net/latest/reference/API/display.html">display()</a> function to route their output (whether text or rich MIME types) to a specific place on the DOM. The <code>output</code> attribute is meant to allow the use of libraries which output directly to <code>stdout</code>, like <a href="https://github.com/Textualize/rich">Rich</a> or <a href="https://pygments.org/">Pygments</a>. Or so, you know, <code>print("Hello World")</code> doesn't have to print in the same location as the <code>&lt;py-script&gt;</code> tag.</p>
<p class="post-p"></p>

<h4 class="post-h4 md:border-b-2 md:border-gray-200">"<code>runtime</code>" is now "<code>interpreter</code>"</h4>
<p class="post-p">The attribute of the PyScript object which represents the internal Python interpreter has been renamed from <code>runtime</code> to <code>interpreter</code>. (<a href="https://github.com/pyscript/pyscript/pull/1082">#1082</a>) This is largely an internal PyScript naming change, but it does have ramifications for some users who were making use of this key access attributes of the runtime, as in:</p>
<div>
    <span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    //Previous naming using 'pyscript.runtime'
    function showX_2022_12_1(){
        console.log(`In Python right now, x = ${pyscript.runtime.globals.get('x')}`)
    }

    //Updated attribute name in PyScript 2023.03.1 and later
    function showX_2023_03_1(){
        console.log(`In Python right now, x = ${pyscript.interpreter.globals.get('x')}`)
    }
{{< /highlight >}}
{{< highlight "html" "linenostart=11">}}
</script>
{{< /highlight >}}
</div>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Hiding the Splashscreen</h4>
<p class="post-p">Several users have <a href="https://github.com/pyscript/pyscript/issues/900">requested</a> the ability to hide the default splashscreen that's displayed while PyScript is loading. And we heard you! The <code>&lt;py-config&gt;</code> tag now accepts a <code>splashscreen.enabled</code> property (defaults to <code>True</code>). If set to <code>False</code>, the default loading screen will not be shown. (<a href="https://github.com/pyscript/pyscript/pull/1138">#1138</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Auto-IDs for <code>py-[event]</code></h4>
<p class="post-p">A small but very handy update to the <code>py-[event]</code> behavior: users no longer need to specify an ID when adding this attribute to an HTML element. Under the hood, an ID is stilll necessary, but if the user doesn't provide one, PyScript now adds an auto-generated UUID as the ID. (<a href="https://github.com/pyscript/pyscript/pull/1122">#1122</a>)</p>
<div class="m-2">
{{< highlight "html" "linenostart=1">}}
<!-- The 'id' attribute was required in previous versions-->
<button py-click="someFunction()" id="old">Click me!</button>"

<!-- In version<h1 class="text-4xl text-center text-red-800">This is a draft this post hosted on a development server; not for release.</h1> 2023.03.1 and later, an ID will be auto-generated for you -->
<button py-click="someFunction()">Click me!</button>"
{{< /highlight >}}
</div>

<h4 class="post-h4 md:border-b-2 md:border-gray-200">So Long, <code>&lt;py-box&gt;</code>, <code>&lt;py-title&gt;</code>, <code>&lt;py-inputbox&gt;</code>, and <code>&lt;py-button&gt;</code></h4>
<p class="post-p">As previously promised, these elements (which were deprecated in version 2022.12.1) have been removed in version 2023.02.1. (<a href="https://github.com/pyscript/pyscript/pull/1084">#1084</a>). If you were still making use of these custom elements, check out the <a href="../whats-new-pyscript-2022-12-1#widgetdeprecation">2022.12.1 release post</a> for suggested plain HTML elements to use instead.</p>

<h2 class="post-h2" id="plugins">Plugins</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">What Are Plugins?</h4>
<p class="post-p">Plugins are code objects, either in Python or JavaScript, whose methods are called at specific points in the PyScript lifecycle (e.g. as PyScript installs itself, fetches the interpreter, related resources, executes <code>&lt;py-script&gt;</code> tags, etc). Internally, PyScript uses the plugin concept to orchestrate some behaviors like the Splashscreen and the <code>&lt;py-terminal&gt;</code>, but the idea is that these methods are available for users to write their own plugins to hook into.</p>
<p class="post-p">This is a super powerful functionality! Users can (for the most part) rewrite the rules of PyScript and its execution by simply pointing part of the <code>&lt;py-config&gt;</code> at a URL with their plugin resource. You could emit events corresponding to certain actions, pre-scan and parse the Python code and act upon it before the code executes, add additional custom tags that extend PyScript's behavior... the sky's the limit.</p>
<p class="post-p">So if they're so powerful, why isn't there more documentation on Plugins? The honest answer is that <span class="font-semibold">the API is rapidly changing</span>, both in naming conventions and scope, and there's some understandable reticence at putting out a significant amount of functionality that users might rely on, only for the names and conventions to entirely change in the next release. Currently, there are two major outstanding discussions:
    <ul class="post-ul">
        <li>Rename the phases of the page lifecycle and lifecycle methods (<a href="https://github.com/pyscript/pyscript/discussions/1238">#1238</a>)</li>
        <li>Use a metadata file for plugin specification, instead of linking directly to a code file (<a href="https://github.com/pyscript/pyscript/pull/1228">#1228</a>) (<a href="https://github.com/pyscript/pyscript/pull/1229">#1229</a>)</li>
    </ul>
</p>
<p class="post-p">So with both the method names and keys/format likely to change, it's daunting to write documentation that may already be out-of-date by the time it's published. That said, here's a peek at what's changed in the Plugins API since the last release:</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Plugins Can Now be Fetched from URLs</h4>
<p class="post-p">Where in version 2022.12.1 plugin files could only be referenced from specific <code>.py</code> files, a plugin can now be fetch'd from any URL. (<a href="https://github.com/pyscript/pyscript/pull/1065">#1065</a>). What's more, plugins can be written either in Python or in JavaScript.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">PyScript Tag Lifecycle Hooks</h4>
<p class="post-p">In addition to the hooks which happen at specific points in PyScript's loading process, we've added a couple of hooks which are called immediately before and after any <code>&lt;py-script&gt;</code> tags on the page, allowing plugins to check, for example, whether the source code adheres to certain guidelines, or whether the result was of a desired type. (<a href="https://github.com/pyscript/pyscript/pull/1064">#1063</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Plugin Method are Now Optional</h4>
<p class="post-p">Previously, any and all plugins had to be implemented for every plugin, or an error would be thrown. Now, plugins can implement any subset of the plugin methods (or none of them, although then what would be the point?). (<a href="https://github.com/pyscript/pyscript/pull/1134">#1134</a>) </p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">No Duplicate Plugin Calls</h4>
<p class="post-p">I know I said I wasn't going to delve into bugfixes here, but this is one that was plaguing a couple of users with specific issues. In PyScript 2022.12.1, any Python plugins were being added to the list of managed plugins <span class="italic">twice</span>, meaning each of their methods was called twice. This was causing some specific tricky issues where a plugin method (which should only run once) would run once, succeed, then appear to fail... tricksy indeed. That's no longer happening.(<a href="https://github.com/pyscript/pyscript/pull/1064">#1064</a>)</p>

<h2 class="post-h2" id="documentation">Documentation</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Changelog.md</h4>
<p class="post-p">As mentioned at the top, PyScript now has an <a href="https://github.com/pyscript/pyscript/blob/main/docs/changelog.md">incremental Changelog</a>! If you're sick of wading through a couple thousand of my (questionably spelled) words every time there's a release, the Changelog has the short-and-sweet version (<a href="https://github.com/pyscript/pyscript/pull/1066">#1066</a>).</p>
<p class="post-p">Admittedly, the PyScript team is still getting used to updating the changelog as part of our workflow, so it's possible a few small things were missed. That changelog is meant to be primarily user-facing, and doesn't necessarily capture all the changes to PyScript's internals.</p>
<p class="post-p">Since we have this additional central document I've opted to focus this post more on changes in features and utility, rather than minor-but-important changes like bugfixes. If you're interested in seeing what changed in a more specific way, and what previous bugs you can now safely ignore, I'd recommend checking out the changelog.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Event Listeners Documentation</h4>
<p class="post-p">PyScript has a very handy but under-documented way of adding event listeners directly to HTML elements using the <code>py-[event]</code> syntax. At least, it was under-documented until Mariana <a href="https://github.com/pyscript/pyscript/pull/1125">went and wrote some</a>!</p>
<p class="post-p">Fair warning to those making use of this feature, though - the syntax is likely to change in an upcoming version. There's <a href="https://github.com/pyscript/pyscript/discussions/1222">active discussion</a> around the new syntax and a <a href="https://github.com/pyscript/pyscript/pull/1240">PR in the works</a>, so keep your eyes peeled for what the next iteration of that API looks like.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200"><code>requests</code> package / <code>pyodide-http</code> tutorial</h4>
<p class="post-p">Of all the popular Python packages that users wish they could use in the browser, probably the most asked about is <a href="https://requests.readthedocs.io/en/latest/">requests</a>, the ubiquitous package for making HTTP requests. Unfortunately, that package doesn't work natively within the browser, as the user doesn't have access to the same kind of low-level networking capabilities that Python running natively on a computer does.</p>
<p class="post-p">But one person's problem is another person's call to action. <a href="https://twitter.com/mr_le_fox">Koen Vosson</a> has created the <a href="https://github.com/koenvo/pyodide-http">pyodide-http</a> package, which shims both the <code>requests</code> and <code>urllib</code> packages (if desired), allowing code previously written for "desktop flavored" python to just work in the browser. And to get users started smoothly, PyScript now includes a tutorial on how to integrate <code>pyodide-http</code> into your PyScript project. (<a href="https://github.com/pyscript/pyscript/pull/1164">#1164</a>)</p>

<h4 class="post-h4 md:border-b-2 md:border-gray-200">Tutorials Overhaul</h4>
<p class="post-p">The tutorials index page at <a href="https://docs.pyscript.net/tutorials/index.html">docs.pyscript.net/tutorials</a> has gotten a facelift, for a better onboarding process for new users (<a href="https://github.com/pyscript/pyscript/pull/1090">#1090</a>).</p>
<p class="post-p">The PyScript core team is always interested in having more tutorials and guides. Have you figured out how to do something with PyScript that you felt could use better documentation? We'd love to see a <a href="https://github.com/pyscript/pyscript">Pull Request</a>!</p>

<h2 class="post-h2" id="examples">Examples</h2>
<p class="post-p"><a href="https://github.com/romankehr">GitHub User romankehr</a> contributed a new example to the PyScript repository for uploading a CSV file into PyScript and loading it into a Pandas dataframe (<a href="https://github.com/pyscript/pyscript/pull/1067">#1067</a>). For those looking to data-sciency things with Python in the browser, this is a great place to start.</p>

<h2 class="post-h2" id="pyodide">Pyodide</h2>
<p class="post-p"><a href="https://pyodide.org">Pyodide</a>, the CPython-interpreter-in-WASM project that is the primary runtime for PyScript at the moment, has had a couple of releases in recent months; This release brings PyScript up-to-date with <a href="https://pyodide.org/en/stable/project/changelog.html#version-0-22-1">Pyodide 0.22.1</a>, which brings a host of new and nifty features.</p>
<p class="post-p">Pyodide's own <a href="https://blog.pyodide.org/posts/0.22-release/">release notes for version 0.22.0</a> provide a great overview and insight into these changes, but they're so exciting that I can't help but feature them here as well:</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">JS Module Typeshed</h4>
<p class="post-p">Many of PyScript's most powerful features rely on Pyodide's ability to <code>import ... from js</code> to get objects from the JavaScript global namespace. But it does get a little tiring to stare at a squiggy red line underneath every instance of  <span class='rl-outer'><span class='rl-inner'><code>from js import console</code></span></span> or <span class='rl-outer'><span class='rl-inner'><code>js.document.getElementById</code></span></span>. The Pyodide team have added a <a href="https://mypy.readthedocs.io/en/stable/stubs.html">stub (.pyi) file</a> to make things a little better! Simply download a copy of the most recent <a href="https://github.com/pyodide/pyodide/blob/main/src/py/js.pyi">js.pyi</a> file and place in your IDE or project's location for stub files (<a href="https://code.visualstudio.com/docs/python/settings-reference">VS Code</a>, <a href="https://www.jetbrains.com/help/pycharm/stubs.html#quick-navigation">PyCharm</a>) or simply adjacent to your <code>.py</code> file for simply projects. And like magic, intellisense will start filling in common attributes from the JS module! (<a href="https://github.com/pyscript/pyscript/pull/3298">#3298</a>)</p>
<img src="autocomplete.gif" alt="" class="w-full m-auto lg:w-3/4 xl:w-1/2 p-img">
<h4 class="post-h4 md:border-b-2 md:border-gray-200">New Packages</h4>
<p class="post-p">A litany of new packages have been added to Pyodide, including:</p>
<p class="mx-4 post-p ">pycryptodome (<a href="https://github.com/pyodide/pyodide/pull/2965">#2965</a>), coverage-py (<a href="https://github.com/pyodide/pyodide/pull/3053">#3053</a>), bcrypt (<a href="https://github.com/pyodide/pyodide/pull/3125">#3125</a>), lightgbm (<a href="https://github.com/pyodide/pyodide/pull/3138">#3138</a>), pyheif, pillow_heif, libheif, libde265 (<a href="https://github.com/pyodide/pyodide/pull/3161">#3161</a>), wordcloud (<a href="https://github.com/pyodide/pyodide/pull/3173">#3173</a>), gdal, fiona, geopandas (<a href="https://github.com/pyodide/pyodide/pull/3213">#3213</a>), the standard library _hashlib module (<a href="https://github.com/pyodide/pyodide/pull/3206 ">#3206</a>), pyinstrument (<a href="https://github.com/pyodide/pyodide/pull/3258">#3258</a>), gensim (<a href="https://github.com/pyodide/pyodide/pull/3326">#3326</a>), smart_open (<a href="https://github.com/pyodide/pyodide/pull/3326">#3326</a>), pyodide-http (<a href="https://github.com/pyodide/pyodide/pull/3355">#3355</a>) </p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Improved Python Collections APIS</h4>
<p class="post-p">The process by which JavaScript objects are transmogrified (proxied) into Python continues to get more sophisticated - JS objects that feel like they <span class="italic">should</span> behave like the corresponding Python collections now generally do. For instance, JavaScript arrays now implement <code>reverse</code>, <code>__reversed__</code>, <code>count</code>, <code>index</code>, <code>append</code>, and <code>pop</code>, so that they implement the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence">MutableSequence API</a> (<a href="https://github.com/pyodide/pyodide/pull/2970">#2970</a>). This allows us to treat JavaScript arrays much more like a Python list (or other mutable sequence), eliminating the need to manually convert from one type to another. For instance, this is now possible:</p>


<div class="mx-6 my-2">
<span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    var myarray = ["PyScript", "and", "Pyodide", "and", "JavaScript", "Are", "Awesome"]
{{< /highlight >}}
{{< highlight "html" "linenostart=3">}}
</script>
{{< /highlight >}}
{{< highlight "html" "linenostart=4">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=5">}}
    from js import myarray
    item = myarray.pop()
    print(item)
    myarray.append("Super!")
    print(" ".join(myarray))
    print(myarray.count("and"))
{{< /highlight >}}
{{< highlight "html" "linenostart=11">}}
</py-script>
{{< /highlight >}}
<div class="p-2 pl-4 mt-4 text-white bg-black text-mono">
<pre>
Awesome
PyScript and Pyodide and JavaScript Are Super!
2
</p>
</div>
</div>

<p class="post-p">Similarly, Map-like JS objects now implement <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping">MutableMapping</a> (<a href="https://github.com/pyodide/pyodide/pull/3275">#3275</a>),

<div class="mx-6 my-2">
<span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    var myarray = ["PyScript", "and", "Pyodide", "and", "JavaScript", "Are", "Awesome"]
{{< /highlight >}}
{{< highlight "html" "linenostart=3">}}
</script>
{{< /highlight >}}
{{< highlight "html" "linenostart=4">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=5">}}
    from js import myarray
    item = myarray.pop()
    print(item)
    myarray.append("Super!")
    print(" ".join(myarray))
    print(myarray.count("and"))
{{< /highlight >}}
{{< highlight "html" "linenostart=11">}}
</py-script>
{{< /highlight >}}
<div class="p-2 pl-4 mt-4 text-white bg-black text-mono">
<pre>
Awesome
PyScript and Pyodide and JavaScript Are Super!
2
</p>
</div>
</div>

<code>Generators</code>(<a href="https://github.com/pyodide/pyodide/pull/3294">Pyodide  #3294</a>)</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Destructuring JS Objects with python <code>match</code></h4>
<p class="post-p">Here's a neat one, combining the features of Python >3.10's <code>match</code> statement with JavaScripts (relatively simple) <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">object structure</a>. (<a href="https://github.com/pyodide/pyodide/pull/3273">Pyodide #3273</a>)</p>
<p class="post-p">If you have some JavaScript object that you've imported into Python, it will (unless it's a very simple object) be a <a href="https://pyodide.org/en/stable/usage/api/python-api/ffi.html#pyodide.ffi.JsProxy">JsProxy object</a> that behaves like a Pythonic "interpretation" of the JavaScript object, with a few additional attributes and methods related to the proxy-ing behavior itself. One of these additional methods is the <a href="https://pyodide.org/en/stable/usage/api/python-api/ffi.html#pyodide.ffi.JsProxy.as_object_map">as_object_map()</a> function, which, as the Pyodide docs say: <span class="italic">returns a new JsProxy that treats the object as a map</span>. This can be useful in several circumstances, but one in particular is using it with the match statement, as follows:</p>
<div class="mx-6 my-2">
<span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    var actor = {
        name: "Keanu",
        role: "Neo",
        action: () => {
            console.log("I know kung foo")
        }
    }
{{< /highlight >}}
{{< highlight "html" "linenostart=9">}}
</script>
{{< /highlight >}}
{{< highlight "html" "linenostart=10">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=11">}}
    import js
    pyActor = js.actor.as_object_map()
    for key, value in pyActor.items():
        print(f"{key}: {value}")

    match pyActor:
        case {"name": name, "role": role}:
            print(f"This actor is named {name} in the role {role}")
        case _:
            print("No match")
{{< /highlight >}}
{{< highlight "html" "linenostart=21">}}
</py-script>
{{< /highlight >}}
<div class="p-2 pl-4 mt-4 text-white bg-black text-mono">
<pre>
name: Keanu
role: Neo
action: () => {
            console.log("I know kung foo")
        }
This actor is named Keanu in the role Neo
</p>
</div>
</div>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">JS <code>Promises</code> are <code>thenable</code> in Python</h4>
<p class="post-p">For users coming from the JavaScript world, it's perfectly natural to create a <a href="https://masteringjs.io/tutorials/fundamentals/thenable">chain of thenables</a> - that is, a sequence of objects that have a <code>then()</code> method, each calling its next one when its promise resolves. This makes it easy to write out a succession of functions, each one returning a promise that should be awaited, in a reasonable way.</p>
<p class="post-p">Now, it's possible to do the same kind of then-ing directly in Python: (<a href="https://github.com/pyodide/pyodide/pull/2997">Pyodide #2997</a>)</p>
<div class="mx-6 my-2">
<span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    var actor = {
        name: "Keanu",
        role: "Neo",
        action: () => {
            console.log("I know kung foo")
        }
    }
{{< /highlight >}}
{{< highlight "html" "linenostart=9">}}
</script>
{{< /highlight >}}
{{< highlight "html" "linenostart=1">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=2">}}
    #Example borrowed from the Pyodide tests
    import asyncio

    async def fetch_demo():
        from js import fetch

        name = (
            await fetch("https://pypi.org/pypi/pytest/json")
            .then(lambda x: x.json())
            .then(lambda x: x.info.name)
        )
        print(name)
        
    asyncio.ensure_future(fetch_demo())
{{< /highlight >}}
{{< highlight "html" "linenostart=16">}}
</py-script>
{{< /highlight >}}
<div class="p-2 pl-4 mt-4 text-white bg-black text-mono">
<pre>
pytest
</p>
</div>
</div>


<h4 class="post-h4 md:border-b-2 md:border-gray-200">JS Proxy Descriptors (Using JS Functions as Python Methods)</h4>
<p class="post-p">At a recent PyScript team gathering, I was musing with Pyodide core dev <a href="https://github.com/hoodmane">Hood</a> about the possibility of subclassing a JavaScript object in Python, so that one could write the "JavaScripty" behaviors of one's class in JavaScript and subclass it into Python to handle the "Pythony" bits. Hood kindly let me know that that way probably lies madness, but that it <span class="italic">is</span> now possible to use JavaScript functions as Python methods, which accomplished much of the same thing. (<a href="https://github.com/pyodide/pyodide/pull/3130">#3130</a>). And if the function is defined within the Python class statement, the <code>this</code> object references the current Python object (like <code>self</code>):</p>

<div class="mx-6 my-2">
<span class="bg-red-600"></span>
{{< highlight "html" "linenostart=1">}}
<script>
{{< /highlight >}}
{{< highlight "js" "linenostart=2">}}
    var area = (a, b) => {
        return .5 * a * b
    }
{{< /highlight >}}
{{< highlight "html" "linenostart=5">}}
</script>
{{< /highlight >}}
{{< highlight "html" "linenostart=6">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=7">}}
    import js
    from pyodide.code import run_js

    class Triangle():
        def __init__(self, a, b):
            self.a = a
            self.b = b

        area = js.area
        hypo = run_js("function h() {return Math.hypot(this.a, this.b);} h")
        
    c = Triangle(a=3, b=4)
    print(f"Area is: {c.area(c.a, c.b)}")
    print(f"The hypotenuse is {c.hypo()}")
{{< /highlight >}}
{{< highlight "html" "linenostart=21">}}
</py-script>
{{< /highlight >}}
<div class="p-2 pl-4 mt-4 text-white bg-black text-mono">
<pre>
Area is: 6
The hypotenuse is 5
</p>
</div>
</div>


<h4 class="post-h4 md:border-b-2 md:border-gray-200">Mounting the Native Filesystem</h4>
<p class="post-p">By default, when Python in PyScript/Pyodide interacts with the filesystem (when writing something like <code>with open(...) as ...</code>), it references a "virtual", <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html#memfs">in-memory filesystem</a> that lives in the browser window's memory for as long as the page exists. But Emscripten, the c-program-to-Web-Assembly compiler that Pyodide uses to build CPython for the web, offers <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html">additional filesystem options</a>, one of them being <a href="https://developer.chrome.com/articles/file-system-access/">Chrome's interface for mounting directories directly</a>. (<a href="https://github.com/pyodide/pyodide/pull/2987">Pyodide #2987</a>)</p>
<p class="post-p">One thing to note: mounting a local folder into the browser - like <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/User_actions">some other potentially-invasive browser actions</a> - can only be triggered when handling a user interaction. This is so you can't, say, open Reddit and immediately be asked to mount a folder on your computer into the browser. You can imagine the kind of chaos that would cause.</p>
<p class="post-p">This functionality currently only works in Chrome/Chromium, though it does seem that other browsers are picking it up as well.</p>
<p class="post-p">This is a neat-enough functionality that I want offer a live demo here. If you are using Chrome/Chromium, you can choose to mount a folder on your filesystem here, and PyScript will print the listing of its contents.</p>
<p class="post-p"><span class="font-bold text-red-700">But Beware!</span> When you click the button below, you will be asked for a folder on your computer that the PyScript/JavaScript code that runs will have access to. You can inspect the source on this page and see for yourself what I'm doing, and I do guarantee that it's the code you see on the page here, but I want you to be aware - by mounting this folder, <span class="font-semibold">you are implicitly trusting me, Jeff Glass, with the contents of whatever's inside that folder.</span></p>{{< highlight "html" "linenostart=1">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=2">}}
    from js import showDirectoryPicker, Object
    from pyodide.ffi import to_js
    import pyodide_js
    import os

    async def requestAndPrintFolder():
        modeObject = to_js({ "mode": "readwrite" }, dict_converter=Object.fromEntries)
        dirHandle = await showDirectoryPicker()
        if await dirHandle.queryPermission(modeObject) != "granted":
            if await dirHandle.requestPermission(modeObject) != "granted":
                raise Exception("Unable to read and write directory")
        nativefs = await pyodide_js.mountNativeFS("/mount_dir", dirHandle)
        
        print(os.listdir('/mount_dir'))
{{< /highlight >}}
{{< highlight "html" "linenostart=16">}}
</py-script>
<button py-click="requestAndPrintFolder()">Click to request folder</button>
{{< /highlight >}}
<div class="load-pyscript"></div>
<div class="hidden live-example">
    <py-script class="hidden">
        from js import showDirectoryPicker, Object
        from pyodide.ffi import to_js
        import pyodide_js
        import os
    
        async def requestAndPrintFolder():
            modeObject = to_js({ "mode": "readwrite" }, dict_converter=Object.fromEntries)
            dirHandle = await showDirectoryPicker()
            if await dirHandle.queryPermission(modeObject) != "granted":
                if await dirHandle.requestPermission(modeObject) != "granted":
                    raise Exception("Unable to read and write directory")
            nativefs = await pyodide_js.mountNativeFS("/mount_dir", dirHandle)
            
            print(os.listdir('/mount_dir'))
    </py-script>
    <div class="flex justify-center w-full mt-3 align-center"><button id="btn1" py-click="requestAndPrintFolder()" class="w-full px-4 py-2 bg-yellow-300 border-2 rounded-md md:w-1/2">Click to request folder</button></div>
    <py-terminal></py-terminal>
</div>
<p class="post-p"></p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Package Loading Improvements</h4>
<p class="post-p">Pyodide v0.22 brings a number of changes and improvements to the package loading process, most of which won't be immediately visible to casual users of PyScript, but which are useful to know. The biggest of which is that <code>micropip</code>, the pip-like software that handles installing packages from both PyPI and the Pyodide packages, has been moved to <a href="https://github.com/pyodide/micropip">it's own repository</a> so it can be maintained separately from Pyodide itself. It also allows users to install different versions or copies of micropip, as opposed to being locked to one that's bundled with Pyodide.</p>
<p class="post-p">Additionally, the error messages that Pyodide provides when a package fails to load have been beefed up quite a bit (<a href="https://github.com/pyscript/pyscript/pull/3137">#3137</a>) (<a href="https://github.com/pyscript/pyscript/pull/3263">#3263</a>)</p>
<p class="post-p">For more details, see the <a href="https://pyodide.org/en/stable/project/changelog.html#id1">Package Loading section</a> of the Pyodide changelog.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Build System Improvements</h4>
<p class="post-p">If you're interested in building packages for Pyodide, or working within the Pyodide build system, version 0.22 brings another swath of improvements. There are some new commands in the pyodide CLI which allow for finer control of the build process for specific packages, or from which sources to build. Also, the <code>meta.yml</code> files that specify the build process for particular packages have been expanded. For more details, see the <a href="https://pyodide.org/en/stable/project/changelog.html#id2">Build System section</a> of the Pyodide changelog.</p>
<p class="post-p">Beyond that, Pyodide is now using the most recent Emscripten version (3.1.27, from 3.1.14), which I gather is quite nice, but honestly a little deeper in the stack than your humble author is familiar with. For details on that, check <a href="https://github.com/emscripten-core/emscripten/blob/main/ChangeLog.md">the Emscripten Changelog</a>.</p>

<h2 class="post-h2" id="whatsnext">What's Next?</h2>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Web Workers</h4>
<p class="post-p">This was a topic we touched on briefly <a href="../whats-new-pyscript-2022-12-1#webworkers">in the last release post</a>, but a huge amount of progress has been made in this area since then... just not quite in a user-facing way.</p>
<p class="post-p">The gist of using Web Workers, you'll recall, is to offload the actual Python execution to a separate thread so it doesn't block the main browser thread while it's executing "in the background." This means that all calls in the main thread to "run some Python" become asynchronous, which comes with its own pitfalls. The gist of the process so far is:
    <ul class="mx-4 space-y-2"><li><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="#669966" class="inline-block w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Make calls to <code>runPython</code> into <code>async</code> calls. Don't do anything else different, just make sure the lifecycle is still consistent, everything that needs to be <code>await</code>ed is awaited, etc. (<a href="https://github.com/pyscript/pyscript/pull/1212">#1212</a>)</li>
    <li><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="#669966" class="inline-block w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Split the Interpreter class (which is PyScripts abstraction around Pyodide and other future interpreters) into two classes, <code>InterpreterClient</code> and <code>RemoteInterpreter</code>. One calls the other, but other live in the main thread. (<a href="https://github.com/pyscript/pyscript/pull/1218">#1218</a>)</li>
    <li><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="#CC9999" class="inline-block w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M14.25 9v6m-4.5 0V9M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>Move the <code>RemoteInterpreter</code> to a Web Worker (this is the easy part, but then...)</li>
    <li><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="#CC3333" class="inline-block w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>Work out all the message passing/proxying to maintain communication between the main thread and remote thread. This is (maybe?) the most complicated part - Antonio, Madhur, and Hood's combined efforts have yielded a <a href="https://github.com/pyscript/pyscript/tree/antocuni/play-with-workers">hacked together demo</a> which does indeed run all the Python code in a web worker. It uses the <a href="https://github.com/hoodmane/synclink">synclink library</a> to make the synchronous actions in Python block correctly while waiting for a response from the main thread, as well as handling message passing.</li>
    </ul>
    </p>
<p class="post-p">But my understanding here is there's still quite a bit of work to be done before this effort is ready to merge. But that by no means should take away from the tremendous effort already put in! Really cool things are coming in this area.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Events Overhaul</h4>
<p class="post-p">Another issue still circling since the previous release, but after a recent PyScript core team gathering, I think we have a way forward. The new <code>py-[event]</code> syntax (which to emphasize is <span class="italic">not</span> in this release) will be:
    <ul class="post-ul">
        <li>For any browser event <code>[event]</code>, the attribute <code>py-[event]="someCallable"</code> can be added to any HTML element. When the specified event is triggered on that HTML element, the Callable will be called.</li>
        <li class="ml-6">If the callable takes no arguments, it will be called with no arguments. If the callable takes a single argument, the <code>event</code> object generated by the browser event will be passed to it. If it takes two or more arguments, an Exception is raised.</li>
        <li>For any browser event <code>[event]</code>, the attribute <code>py-[event]-code="someExpression()"</code> can be added to any HTML element. When the specified event is triggered on that HTML element, the expressed is <code>eval()</code>'d in the global namespace</li>
    </ul>
</p>
<p class="post-p">The following examples illustrate the difference between the two scenarios: <code>py-[event]</code> is for <span class="italic">registering event handlers</span>, whereas <code>py-[event]-code</code> is for <span class="italic">running snippets of code</span>:</p>
<div class="code-title">py-[event]</div>
{{< highlight "html" "linenostart=1">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=2">}}
    def printEventTarget(event):
        print(event.target)
{{< /highlight >}}
{{< highlight "html" "linenostart=4">}}
</py-script>
<button py-click="printEventTarget">Click me to print a reference to this button</button> 
{{< /highlight >}}
<br>
<div class="code-title">py-[event]-code</div>
{{< highlight "html" "linenostart=1">}}
<py-script>
{{< /highlight >}}
{{< highlight "python3" "linenostart=2">}}
    def addition(a, b):
        return a + b
{{< /highlight >}}
{{< highlight "html" "linenostart=4">}}
</py-script>
<button py-click="print(f'{addition(2, 3)= }')">What is two plus three?</button> 
<button py-click="print('Hello, world!')">Click me to print Hell Worldo</button> 
{{< /highlight >}}
<p class="post-p">Just to say it one more time - this syntax is <span class="font-semibold">coming soon</span> and is <span class="italic">not</span> a part of this release. We're getting close though.</p>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">Pyxel in Pyodide</h4>
<p class="post-p">Pyodide core dev <a href="https://github.com/ryanking13">Gyeongjae Choi</a> has <a href="https://github.com/pyodide/pyodide/pull/3508">a development branch</a> in the works that I'm personally very excited about - it compiled Pyodide with Emscripten support for SDL (<a href="https://www.libsdl.org/">Simple DirectMedia Layer</a>), a cross-platform graphics library. It powers lots of desktop-oriented graphics software, like <a href="https://www.pygame.org/news">Pygame</a> and <a href="https://github.com/kitao/pyxel">Pyxel</a>. The branch is specifically working on integrating Pyxel, since it's written mostly in Python and Rust, which Pyodide has been increasingly included as a supported language to build against.</p>
<p class="post-p">Now, Pyxel already has a <a href="https://github.com/kitao/pyxel#web">build-to-web</a> option which compiles the requisite components into Web Assembly and spits out an html file that wraps it. But with Pyodide integration, we get all the nifty browser and JS interoperability features that we've come to love in PyScript. For example, we can not only run games in the browser, but we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">LocalStorage</a> to save user data, add HTML control or display elements <span class="italic">outside</span> of the game, respond to window events, or even allow game objects to be <span class="italic">directly scripted  by Python, in realtime, in the browser.</span>. How cool is that?></p>
<p class="post-p">So cool I had to build a little demo, that's how cool.</p>
<p-post>To be clear, this is all still experimental - the following demo is built against a version of Pyodide that doesn't exist in the wild, that I built from Gyeongjae's dev branch. But I got so excited about the possibilities that I just had to try it out.</p-post>
<p class="post-p">As an example of what's possible with Pyxel in the browser, try putting focus on another browser window - you'll see that the game detects the window event and automatically pauses. Additionally, this demo uses the browser's local storage to keep track of your best time.</p>
<div class="mb-2 text-center">
    <p class=""><span class="font-semibold">CONTROLS</span> Move: Left/Right      Jump: Up or Space     Pause: P </p>
</div>
<py-config class="hidden">
    packages = ['pyxel']

    [[fetch]]
    files = ['animated.py', 'collision.py', 'frame.py', 'images.pyxres', 'level.py', 'main.py', 'protocols.py', 'sounds.pyxres', 'wabbit-wesources.pyxres', 'wabbit.py', 'objects/coin.py']
    from = 'https://dev.jeff.glass/wasm-wabbit-game/src'

    [[fetch]]
    files = ['level_1.pyxres', 'level_2.pyxres', 'level_3.pyxres']
    from = 'https://dev.jeff.glass/wasm-wabbit-game/src/levels'
    to_folder = 'levels'

    [[interpreters]]
    src = "https://jeff-glass-dev.s3.amazonaws.com/pyodide-pyxel/pyodide.js"
    name = "pyodide-0.22.1-pyxelbuild"
    lang = "python"
</py-config>
<py-script class="hidden">
    import pyodide.code

    pyodide.code.run_js(
        """
        pyscript.interpreter._remote.interface._module.canvas = document.querySelector("canvas#canvas");

        _virtualGamepadStates = [
            false, // Up
            false, // Down
            false, // Left
            false, // Right
            false, // A
            false, // B
            false, // X
            false, // Y
        ];
        """
    )
    from main import App
    App()
</py-script>
<div class="relative static-example" onclick="loadPyScript()">
    <img src="./wabbit-cover.png" alt="" class="w-full p-2 m-auto border-2 rounded-lg lg:w-1/2 md:w-3/4" style="cursor: pointer">
    <div class="absolute px-8 py-2 text-4xl font-semibold border-2 border-gray-900 rounded-lg load-pyscript-button" style="top:60%; left:50%; transform: translateX(-50%); background-color: #fda703; color: #2C2E34; cursor: pointer;" >Load Demo</div>
</div>

<div class="">
    <canvas id="canvas" tabindex="-1" class="hidden live-example"></canvas>
</div>
<h4 class="post-h4 md:border-b-2 md:border-gray-200">And more...</h4>
<p class="post-p">As I <a href="#tease">teased</a> about 3500 words ago, there are some very cool things coming soon for PyScript; if you want to be the first to hear about them, come join us on <a href="https://discord.gg/Y5MFvW5hbs">The Discord Server</a> </p>