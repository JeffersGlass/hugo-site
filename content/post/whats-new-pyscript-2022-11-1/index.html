---
title: "What's New in Pyscript 2022.11.1"
date: 2022-10-25T10:12:48-05:00
draft: true
tags:
- Python
- PyScript
- Pyodide
- JavaScript
description: "The big changes in PyScript version 2022.11.1"
slug_image: py_2022_11_1_featured.png
---
<style>
    code:not(.nocode){
        --tw-text-opacity: 1;
        color: rgba(5, 120, 85, var(--tw-text-opacity));
    }
</style>

<p class="post-p">Another month, another big release for PyScript! With a shorter release cycle, there's been less time for upstream projects (Pyodide, Emscripten) to move ahead, but there's still been loads of work done on PyScript in the past month.</p>
<div id="TOC" class="grid justify-center p-1 m-auto bg-gray-200">
    <span>Jump To: <span>
    <a href="#Display">display()</a> • 
    <a href="#paths">[[fetch]]</a> • 
    <a href="#PyScript">PyScript</a> • 
    <a href="#Community">Community</a> • 
    <a href="#infrastructure">Infrastructure</a> • 
    <a href="#Team">The PyScript Team</a> • 
    <a href="#Next">What's Next?</a>
</div>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="Display"><code class="text-green-600">display()</code></h2>
<p class="post-p">There's one change to the PyScript API that's so big, it's getting its own whole section! And it has to do with how PyScript outputs to the browser window. <span class="font-bold"><code>print()</code> no longer outputs to the browser window!</span> (<a href="https://github.com/pyscript/pyscript/pull/749">#749</a>)</p>
<p class="post-p">One key Python concept to know here is <a href="https://docs.python.org/3/library/sys.html?highlight=stdout#sys.stdout">sys.stdout</a>, a File object that Python writes to when it wants to <code>print()</code> something to the terminal, display an <code>input()</code> prompt, and so on. Other modules may write directly to <code>stdout</code> if they wish, but <code>print()</code> is by far the most visible use of <code>stdout</code>.</p>
<p class="post-p">Prior to 2022.11.1, Python's <code>sys.stdout</code> was routed <span class="italic">to the screen</span> via fairly complicated <a href="https://github.com/pyscript/pyscript/blob/beb3aa157419ecb53863c76674069c78cb48dfe1/pyscriptjs/src/python/pyscript.py#L368-L419">wrapper setup</a>. However, a browser window has so many more dimensions of possibility for where we might want to place content compared to a terminal. Thus, the metaphor of "use <code>print()</code> and we'll guess where to put your content" doesn't really hold up.</p>
<p class="post-p">As of 2022.11.1, <span class="font-bold"><code>print()</code> goes to the developer console; <code>display()</code> is for outputting to the browser window</span>:</p>
<div class="py-2 pl-2 m-0 ml-4 bg-green-100">
    <h4 class="text-xl"><code class="nocode" >display(*values, target=None, append=True)</code></h4>
    <div class="ml-4">
        <p class="pt-1 text-justify"><span class="font-bold">*values</span> (<code>list</code>) - the list of objects to be displayed. Can be any of the following MIME types:: "text/plain", "text/html", "image/png", "image/jpeg", "image/svg+xml", "application/json" or "application/javascript"</p>
        <p class="pt-1 mt-2 text-justify"><span class="font-bold">target</span> (<code>str</code>)- the ID of the html tag to output to. If <code>none</code>, output to the current <code>&lt;py-script&gt;</code> tag.</p>
        <p class="pt-1 mt-2 text-justify"><span class="font-bold">append</span> (<code>boolean</code>) if the output is going to be appended or not to the `target`ed element. It creates a <code>&lt;div&gt;</code> tag if <code>True</code> and a <code>&lt;py-script&gt;</code> tag with a random ID if <code>False</code></p>
    </div>
</div>
<p class="post-p">So for example, in place of the usual <code>print("Hello, world")</code>, one could do one of these (they have slightly different behaviors - try them out!):</p>
<div class="p-2 mx-4 my-2" style="background-color: #f0f3f3">
{{< highlight "python" "linenos=false" >}}
display("Hello World!")

display("Hello", "World!", append=True)

display("Hello")
display("World", append=True){{< /highlight >}}
</div>
<p class="post-p">Following another PR by Antonio (<a href="https://github.com/pyscript/pyscript/pull/915">#915</a>), <code>display()</code> escapes any HTML given to it as an input string, so <code>display(&lt;br&gt;)</code> prints the literal characters <code class="code">&lt;br&gt;</code> to the screen, instead of creating a newline. For non-string inputs, <code>display(some_obj)</code> calls <code>repr(some_obj)</code> and escapes that. If you <span class="italic">do</span> want to inject HTML into your page, a new object is to use the new <a href="https://github.com/pyscript/pyscript/blob/515858f3134bf031497f0420e8a0e7fbc4c32be0/pyscriptjs/src/python/pyscript.py#L49">HTML class</a>, a la <code>display(HTML("&lt;p&gt;A new paragraph&lt;/p&gt;"))</code>.</p>
<p class="post-p">So if <code>display()</code> is for writing to the screen, what does <code>print()</code> do? It writes to the <a href="https://support.monday.com/hc/en-us/articles/360002197259-How-to-open-the-developer-console">Developer Console</a>. This is the closest analog in the browser to a "dumb terminal", and so it makes a certain amount of sense for <code>stdout</code> to be routed there.</p>
<p class="post-p">There are certain small differences, since of course the dev console <span class="italic">isn't</span> a terminal. For instance, we discovered just the other day that <code>console.log()</code> (which is used to write to the dev console) <a href="https://github.com/pyscript/pyscript/issues/472#issuecomment-1281228942">doesn't output unless it receives a newline</a>. So something like <code class="code">print("Hello world", end = "")</code> won't show up until you log something else with a newline in it!</p>
<p class="post-p">If I were a betting man, I'd hedge that the API for <code>display()</code> is likely to continue to change and evolve. It's a brand-new and breaking feature, and I suspect its semantics are going to continue to get tweaked. If you find more issues or inconsistencies, be sure to <a href="https://github.com/pyscript/pyscript/issues">raise an issue on GitHub</a> or come tell us about it <a href="https://discord.gg/CQU2Qyeb">on the PyScript Discord</a>.</p>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="paths">Fetching Files with <code>&lt;py-config&gt; [[fetch]]</code></h4>
<p class="post-p">Previously, all files listed in <code>&lt;py-config&gt; paths:</code> were <code>fetch()</code>'d from the listed URLs and dropped into the embedded filesystem in the same folder as the running Python Script. Which is to say, pointing a path to the relative URL <code class="code">'data/files/Feb-24/info.txt'</code> would make that file available via <code class="code">with open('info.txt')... </code>.</p>
<p class="post-p bg-red-400">Now, there are additional options for fetching multiple files in a way that preserves their URL/directory structure. They're all bundled into a new "fetch configuration" table in <code>&lt;py-config&gt;</code> labelled <code>[[fetch]]</code>, with the following members:</p>
<table class="m-2">
    <tr class="font-bold">
        <td>Value</td>
        <td>Type</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>`from`</td>
        <td>string</td>
        <td>Base URL for the resource to be fetched.</td>
    </tr>
    <tr>
        <td>`to_folder`</td>
        <td>string</td>
        <td>Name of the folder to create in the filesystem.</td>
    </tr>
    <tr>
        <td>`to_file`</td>
        <td>string</td>
        <td>Name of the target to create in the filesystem. Cannot be combined with "files"</td>
    </tr>
    <tr>
        <td>`files`</td>
        <td>List of string</td>
        <td>List of files to be downloaded. Cannot be combined with "to_file"</td>
    </tr>
</table>
<p class="post-p">The pseudo-code for what PyScript will fetch is something like this:</p>
{{< highlight "python3" "linenos=false" >}}
    if both "files" and "to_file" are specified: Error

    if "from" is not specified, from = "" #defaults to relative URLs
    if "to_folder" is not specified, to_folder = "." #defaults to the working current directory, where Python Scripts are run format    

    if "files" is specified:
        for each file in "files":
            #These concatenations are done in a smart way to try to avoid dangling/missing "/"s
            source_URL = "from" + file 
            destination = "to_folder" + file
            download object from the source_url to destination in the local file system

    else: #"files" not specified:
        if "to_file" is specified:
            download object from url "from" to "to_folder" + "to_file"
        else if "from" ends in a file-name: #i.e. the part after the last "/" 
            download object from url "from" to "to_folder" + 'filename' at end of "from"{{< /highlight >}}
<p class="post-p">Let's look at some recipies for using these new attributes to fetch resoures from the web and download them to the Emscripten local file system to Python can use them. For the examples where we're fetching our own files and modules, we'll assume our site has the following simple structure:</p>
<pre class="bg-gray-200 p-4">
my-site/
├─ content/
│  ├─ info.txt
│  ├─ <span class="font-bold">index.html <<< File with &lt;py-config&gt;</span>
├─ files/
│  ├─ data.csv
├─ packages/
│  ├─ my_package/
│  │  ├─ __init__.py
│  │  ├─ helloworld/
│  │  │  ├─ __init__.py/
│  │  │  ├─ greetings.py/
</pre>
<div class="grid grid-cols-1 xl:grid-cols-2 mt-4 gap-x-3 gap-y-4">

<div class="w-full">
<p class="code-title">Single File</p>
<div class="pr-4 bg-codeblock">
{{< highlight "html" >}}

<py-config>
    [[fetch]]
    files = ['info.txt']
    # URL defaults to 'relative to this folder'
    # Destination defaults to 'adjacent to the Python files we run'
</py-config>

<py-script>
    with open('info.txt', 'r') as fp:
        print(fp.read())
</py-script>
{{< /highlight >}}
</div>
</div>

<div class="w-full">
    <p class="code-title">Single File w/ Renaming</p>
    <div class="pr-4 bg-codeblock">
    {{< highlight "html" >}}
<py-config>
    [[fetch]]
    from = 'info.txt'
    to_file = 'info_loaded_from_web.txt'
</py-config>

<py-script>
    with open('info_loaded_from_web.txt', 'r') as fp:
        print(fp.read())
</py-script>{{< /highlight >}}
    </div>
    </div>

<div class="w-full">
<p class="code-title">To Another Local Folder</p>
<div class="pr-4 bg-codeblock">
{{< highlight "html" >}}

<py-config>
    [[fetch]]
    files = ['info.txt']
    to_folder = 'infofiles/loaded_info' 
    # trailing slash would also be acceptable: 'infofiles/loaded_info/' 
</py-config>

<py-script>
    with open("infofiles/loaded_info/info.txt", "r") as fp:
        print(fp.read())
</py-script>
{{< /highlight >}}
</div>
</div>

<div class="w-full">
    <p class="code-title">From Another Folder to Current Working Directory</p>
    <div class="pr-4 bg-codeblock">
    {{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['sensordata.csv']
    from = '../data/'
    # fetch file from URL '../data/sensordata.csv' to local file './sensordata.csv'
</py-config>

<py-script>
    import csv
    with open("./sensordata.csv", "r") as csvfile:
        datareader = csv.reader(csvfile)
        for row in datareader:
            print(row)
</py-script>{{< /highlight >}}
    </div>
    </div>

    <div class="w-full">
        <p class="code-title">Multiple Files, Preserving Folder Structure</p>
        <div class="pr-4 bg-codeblock">
{{< highlight "html" >}}
<py-config>
    [[fetch]]
    files = ['__init__.py', 'helloworld/greetings.py', 'helloworld/__init__.py']
    from = '../packages/my_package/'
    to_folder = './my_package'
</py-config>

<py-script>
from my_package.helloworld.greetings import say_hi
print(say_hi())
</py-script>{{< /highlight >}}
        </div>
        </div>

    <div class="w-full">
        <p class="code-title">From an API Endpoint</p>
        <div class="pr-4 bg-codeblock">
{{< highlight "html" >}}
<py-config>
    [[fetch]]
    from = 'https://catfact.ninja/fact'
    to_file = './cat_fact.json'
</py-config>

<py-script>
import json
with open("cat_fact.json", "r") as fp:
    data = json.load(fp)
display(data['fact'])
</py-script>{{< /highlight >}}
        </div>
        </div>

</div>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="PyScript">PyScript</h2>
<h4 class="post-h4">PyScript JS module</h4>
<p class="post-p"><code>pyscript.js</code> now exposes the instance of Pyodide it creates <a href="https://docs.pyscript.net/latest/reference/pyscript-module.html">as a JavaScript object</a>. Users wishing to run code directly in Pyodide, or to use another JavaScript module that interacts directly with Pyodide, can use this exported reference to do so. (<a href="https://github.com/pyscript/pyscript/pull/868">#868</a>)</p>
<p class="post-p">The Pyodide runtime is accessible as <code class="code">pyscript.runtime.interpreter</code>, like so:</p>
<div class="mx-4 my-2">
{{< highlight "html" >}}
<script defer src="https://pyscript.net/releases/2022.11.1/pyscript.js"></script>
<button onclick="logFromPython()">Click Me to Log</button>
<script>
    function logFromPython() {
        pyscript.runtime.interpreter.runPython(`
            from js import console
            console.log(f"Hello from Python! {1 + 2 = }")
        `)
    }
</script>{{< /highlight >}}
    </div>
<p class="post-p">Note that the runtime will not be available until it has been loaded by PyScript and initialized. In the example above, we use a button to defer executing the desired code until sometime after PyScript has initialized; in the next example, we'll use an <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">Event</a>.</p>
<p class="post-p">The <code class="code">pyscript.runtime.globals</code> attribute holds a reference to Python <code>globals()</code> dictionary, making it easy to reference Python objects from JavaScript. By the wonder that is Pyodide, the objects are proxied back and forth pretty much seamlessly, but especially when logging to the console, using the <a href="https://pyodide.org/en/stable/usage/api/js-api.html#PyProxy.toJs">toJs()</a> function makes the conversion explicit:</p>
<div class="mx-4 my-2">
{{< highlight "html" >}}
<script defer src="https://pyscript.net/releases/2022.11.1/pyscript.js"></script>

<py-script>
    from js import document, Event

    techs = ["PyScript", "Pyodide", "WASM"]
    number_of_techs = len(techs)

    # Use an Event to trigger JS after PyScript has initialized/run:
    pydone = Event.new("py-done")
    document.dispatchEvent(pydone)
</py-script>

<script>
    document.addEventListener("py-done", () => {
        console.log(pyscript.runtime.globals.get("number_of_techs"))
        console.log(pyscript.runtime.globals.get("techs").toJs())
    })
</script>{{< /highlight >}}
    <div class="m-2">
        <p class="italic">Dev Console Result:</p>
        <img class="border-2 border-gray-400" src="consoledemo1.PNG" alt="A pair of entries from the developer console reading '3' and 'PyScript', 'Pyodide', 'WASM'">
    </div>
</div>
<h4 class="post-h4">Better Warnings and Errors</h4>
<p class="post-p">Fabio Rosado (yes, there's <a href="#maintainers">two Fabios</a> on the PyScript team now!) put together a great PR that cleans up the presentation of warnings and errors caused during PyScript startup - if you write invalid TOML for <code>&lt;py-config&gt;</code>, say, or use a deprecated function or feature. (<a href="https://github.com/pyscript/pyscript/pull/909">#909</a>) <span class="italic bg-red-400">(Speaking of which, see below for more notes on deprecated features.)</span></p>
<img src="./warningerror.jpg" alt="A screenshot showing a new-style error banner at the top of an HTML page (with red border) and a warning banner (with an orange border and an 'X' button to close it." class="post-img">
<p class="post-img-caption">The new appearance of warnings and errors caused during PyScript startup and configuration.</p>
<br>
<img src="./python-error.png" alt="A ZeroDivisionError warning box, outlined in red on an HTML page" class="post-img">
<p class="post-img-caption">The new appearance of errors that are thrown when running Python code.</p>
<h4 class="post-h4">Streamlined py-config</h4>
<p class="post-p">The py-config system has been overhauled to simply its use internally - including simplifying how the default configuration options are merged with user-supplied options (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>), dealing with multiple <code>&lt;py-config&gt;</code>s on a page (<a href="https://github.com/pyscript/pyscript/pull/826">#826</a>), and finally killing <code>&lt;py-env&gt;</code> altogether (<a href="https://github.com/pyscript/pyscript/pull/775">#775</a>).</p>
<p class="post-p">The TOML parser handling has also been improved, in that it no longer hangs forever if given misshapen TOML. (<a href="https://github.com/pyscript/pyscript/pull/815">#815</a>)</p>
<p class="post-p">An important clarification has also been added to the docs - because of <a href="https://toml.io/en/">the way the TOML format works</a>, if you're using TOML for your py-config, <code>[[runtimes]]</code> must be the last element. If the <code>[[runtimes]]</code> table precedes the other individual elements (like `paths` or `packages`), those elements end up <span class="italic">inside</span> <code>[[runtimes]]</code>, which will cause them to be missed. (<a href="https://github.com/pyscript/pyscript/pull/861">#861</a>)</p>
<p class="post-p">This in addition to the <a href="#paths">changes to <code>[[fetch]]</code> noted above</a>.</p>
<h4 class="post-h4">Undefined elements are no longer hidden</h4>
<p class="post-p">Previous, any unknown HTML elements were hidden by <code>pyscript.css</code> in an attempt to suppress onscreen visibility of things like <code>&lt;py-config&gt;</code>. This had the unintended consequence of hiding elements with typos - for example, a user-typed <code>&lt;py-scrip&gt;</code> element would be "unknown" and also hidden. Now, PyScript explicitly only hides the page-elements that need hiding. (<a href="https://github.com/pyscript/pyscript/pull/837">#837</a>)</p>
<h4 class="post-h4">Directory Listings for Releases</h4>
<p class="post-p">PyScript releases now come with a directory-listing of files and a brief example. See, for example, <a href="https://pyscript.net/unstable/">https://pyscript.net/unstable</a>. (<a href="https://github.com/pyscript/pyscript/pull/839">#839</a>)</p>
<h4 class="post-h4">CodeMirror 6</h4>
<p class="post-p">Just like <a href="https://blog.jupyter.org/accelerating-jupyterlab-68942bb8d602#2404">JupyterLab 6</a>, PyScript now uses the latest version of CodeMirror to power the in-browser <code>&lt;py-repl&gt;</code> component. This comes with a (far more stable) API and <a href="https://codemirror.net/docs/migration/">lots of other improvements.</a> (<a href="https://github.com/pyscript/pyscript/pull/814">#814</a>)</p>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="Community">Community</h2>
<h4 class="post-h4">Community Call</h4>
<p class="post-">The PyScript core team hosted its <a href="https://github.com/pyscript/pyscript/issues/836">first Community Call</a> on October 18th! (<a href="https://github.com/pyscript/pyscript/issues/836">#836</a>) About a dozen people attended, mostly from the PyScript core team and related contributors. We unfortunately forgot to hit 'record' on the call, but I did jot down a few notes. <span class="italic">(None of this should be taken as gospel or comprehesive; It's just what I, one dude, happened to scribble down.)</span></p>
<ul class="post-ul">
    <li>The team is going to be shooting for about 1 release per month - maybe more, maybe less, but that's a decent goal.</li>
    <li>The lifecycle refactoring is well underway, with Antonio C leading the charge on removing global variables, streamining the loading, etc.</li>
    <li>Similarly, the refactoring away from print() to display() being lead by Mariana was just merged yesterday!</li>
    <li>Plugins!
        <ul class="py-1 pl-8 text-justify list-disc list-outside ul-circle">
            <li>The team is excited about streamlining and <span class="italic">minimizing</span> the core details of what PyScript does. There's a feeling that when PyScript initializes, it should do a 'bare minimum' to get itself running, and delegate lots of core behaviors to plugins, to allow for customizability, extensibility, and futureproofing. An emphasis on PyScript being a 'platform' not a 'framework'</li>
            <li>It is very early days for this idea, but there's lots of excitement around it.</li>
        </ul>
    </li>
    <li>Web Workers are an awesome way to delegrate work, but there's going to be a significant amount of work integrating the message passing/isolation process with PyScript.</li>
    <li>Cleaning up the PyScript API would be nice, in the sense of the Python objects in <a href="https://github.com/pyscript/pyscript/blob/main/pyscriptjs/src/python/pyscript.py#L1-L394">PyScript.py</a> are currently available by default when executing PyScript. Generally, there's agreement around this wanting to all be contained in a module, though there's some questions around what of that would want be <code>import</code>ed by default into a PyScript environment.</li>
        <ul class="py-1 pl-8 text-justify list-disc list-outside ul-circle">
            <li>This would allow IDE's and intellisense to have a chance at working with PyScript.</li>
        </ul>
</ul></p>
<h4 class="post-h4">Awesome PyScript</h4>
<p class="post-p"><a href="#maintainers">Community maintainer</a> Paul Everitt has been hard at work assembling <a href="https://github.com/pyscript/pyscript-collective/blob/main/awesome-pyscript.md">Awesome PyScript</a>, a curated list of awesome things relative to PyScript. If you want inspiration on what PyScript can do, this is the place to go - there's collections of videos, demos, conference talks, and more.</p>
<p class="post-p">Have you done something awesome with PyScript? Drop the Awesome PyScript repo a comment or a Pull Request to have it included!</p>
<h4 class="post-h4">PyScript/Research</h4>
<p class="post-p">A new GitHub repository at <a href="https://github.com/pyscript/research">PyScript/Research</a> has been started, as a home for overarching research, development, and proposals for PyScript. New and great ideas were popping up in issues in the main repo and being lost somewhat, so the new repo is a home for larger proposals that need need multiple files to explain, or that generate longer discussions than fit in a single issue.</p>
<h4 class="post-h4">Discord</h4>
<p class="post-p">The <a href="https://discord.gg/CQU2Qyeb">PyScript Discord</a> is now the official hub for realtime communication around PyScript - both internally for the maintainers and the for the community to gather, ask questions, and get help. Come join us!</p>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="infrastructure">Infrastructure</h2>

<h4 class="post-h4">Dev Docs</h4>
<p class="post-p"><a href="https://docs.pyscript.net/latest/index.html">The PyScript Documentation</a> now has a <a href="https://docs.pyscript.net/latest/development/">Development Section</a>, as a central place for notes about how the development and release process for PyScript works.</p>
<h4 class="post-h4">Refactoring PyScript</h4>
<p class="post-p">Antonio has embarked on several of massive refactoring endevours, to streamline and rationalize the process of how PyScript loads itself and Pyodide and how it then executes Python scripts. Hopefully the changes this imparts to the end-users of PyScript are minimal, but speaking from a maintenance and codebase standpoint, the amount that's been done to make sense of both of these processes makes it a significantly easier to reason about what-happens-when. (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>, <a href="https://github.com/pyscript/pyscript/pull/850">#850</a>, <a href="https://github.com/pyscript/pyscript/pull/881">#881</a>, <a href="https://github.com/pyscript/pyscript/pull/884">#884</a>)</p>
<h4 class="post-h4">Testing</h4>
<p class="post-p">The pytest-driven test system used to re-download the Pyodide runtime and other resources for each test, significantly slowing it down. The test system now has the ability to cache resources between tests, and retry tests on network failures. (<a href="https://github.com/pyscript/pyscript/pull/829">829</a>)</p>
<p class="post-p">We also now have a way for the test system to watch for and confirm that specific errors are being thrown, allowing for the writing of <span class="italic">negative</span> integration tests (that should throw specific errors in PyScript). (<a href="https://github.com/pyscript/pyscript/pull/874">#874</a>)</p>
<h4 class="post-h4">Goodbye Svelte</h4>
<p class="post-p">The original version of the <a href="https://pyscript.net/examples/">PyScript Demo Site</a> and other parts of the build infrastructure and styling were built around <a href="https://svelte.dev/">Svelte</a>. Thanks to several PRs and lots of refactoring, Svelte is now entirely gone (<a href="https://github.com/pyscript/pyscript/pull/806">#806</a>, <a href="https://github.com/pyscript/pyscript/pull/830">#830</a>, <a href="https://github.com/pyscript/pyscript/pull/886">#886</a>) </p>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="Team">The PyScript Team</h2>
<h4 class="post-h4">More Anaconda Contributors</h4>
<p class="post-p">Anaconda Senior Tech Writer Katherine Kinnaman jumped into the Github project, creating issues for much-needed documentation (<a href="https://github.com/pyscript/pyscript/issues/846">#846</a>,<a href="https://github.com/pyscript/pyscript/issues/846">#847</a>,<a href="https://github.com/pyscript/pyscript/issues/846">#848</a>,<a href="https://github.com/pyscript/pyscript/issues/846">#849</a>). And as she mentioned in a comment:
    <blockquote class="post-blockquote">We also figured that if these issues were put out there, maybe a community member might pick it up...</blockquote>
</p>
<p class="post-p">So if you're looking to get your feet wet contributing to the PyScript documentation, this would be a great place to start! Ms. Kinnaman also lists <a href="https://github.com/pyscript/pyscript/issues/848#issuecomment-1289602249">a few criteria for what that documentation would ideally include</a>, as an outline for anyone who wants to take a stab.</p>
<p class="post-p"><span class="italic">Late Breaking News!</span> Engineering Manager Ted Patrick jumped in and created the start of documentation for the <code>&lt;py-script&gt;</code>, <code>&lt;py-repl&gt;</code>, and <code>&lt;py-config&gt;</code> tags! Thanks Ted.</p>
<h4 class="post-h4" id="maintainers">New Maintainers</h4>
<p class="post-p"><a href="https://github.com/pauleveritt">Paul Everitt</a>, <a href="https://github.com/FabioRosado">Fabio Rosado</a> and I are now community maintainers on the PyScript project. It's been tremendously exciting and satisfying working on and with PyScript the past few months - the core team over at Annaconda has been swell all around, and I'm very grateful to be a part of the team in my own way. (<a href="https://github.com/pyscript/pyscript/pull/824">#824</a> <a href="https://github.com/pyscript/pyscript/pull/825">#825</a> (<a href="https://github.com/pyscript/pyscript/issues/898">#898</a>))</p>
<h2 class="pb-1 border-b-2 border-gray-300 post-h2 anchor" id="Next">What's Next?</h2>
<h4 class="post-h4">Events</h4>
<p class="post-p">There's a proposal (a couple proposals) swirling around over in <a href="https://github.com/pyscript/research">PyScript/Research</a> about the syntax for events ("py-[event]" or "onclick" or otherwise). What's exciting is that there's tons of possibilities! Now the hard part will be to sort together the possibilities and potentiatials, weight up the pros and cons (run functions in Python vs. JavaScript, access to JS and/or Python objects as arguments, do we pass literal code or references to Callables, etc) and make the call.</p>
<p class="post-p">...At least for now. This is another area that might see two or three more rounds of evolution before it stabilizes. Or even potentially splits into more than one thing - there may be multiple independent systems being developed that can coexist. Time will tell.</p>
<h4 class="post-h4">Async</h4>
<p class="post-p">Async/Await is still a swirling topic - one that I've personally waded into publishing a <a href="/post/pyscript-asyncio/">long writeup on Asyncio in PyScript</a>. I suspect that one solution (in the near or long-term) may be to eliminate the possibility of doing "Implicit Coroutine Awaiting", since that's essentially a separate code-path from the regular way Python gets run. I personally wouldn't be too sad about that option, even after writting up <a href="https://github.com/pyscript/pyscript/issues/879#issuecomment-1289415317">an embarassingly long screed on how <code class="nocode">runPythonAsync()</code> works</a>.</p>
<h4 class="post-h4">PyScript's Python API</h4>
<p class="post-p">There's some strong agreement among the maintainers, I would say, that something needs to be done about <a href="https://github.com/pyscript/pyscript/blob/beb3aa157419ecb53863c76674069c78cb48dfe1/pyscriptjs/src/python/pyscript.py">PyScript.py</a>, the Python side of what PyScript is. Right now, the file in its entirity is run when the Pyodide runtime starts and its... a lot. There's a lot of great functionality there - especially with the new display() syntax being merged - but it feels little haphazard. There's a sense that it should maybe be... a module? A package? Several modules? Something an IDE can ingest and use for autocompletion say. Or maybe there's a better way?</p>
<p class="post-p">And once that Python is rationalized, there's the question of "How many of the objects defined in this file(s) should be imported by default?" All/some/none? Are some core enough to what PyScript "is" that they should always be imported? Key questions for sure, and ones which will probably break things when answered. But breaking things is good!</p>
<p class="post-p">Here's to breaking more things.</p>
